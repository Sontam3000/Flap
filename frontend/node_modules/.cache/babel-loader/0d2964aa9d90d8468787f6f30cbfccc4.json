{"ast":null,"code":"'use client';\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { useUncontrolled, useId, useResizeObserver, useTimeout, useMergedRef } from '@mantine/hooks';\nimport { getRadius, getSize, getFontSize } from '../../core/utils/get-size/get-size.mjs';\nimport { getEnv } from '../../core/utils/get-env/get-env.mjs';\nimport { createVarsResolver } from '../../core/styles-api/create-vars-resolver/create-vars-resolver.mjs';\nimport 'clsx';\nimport { getThemeColor } from '../../core/MantineProvider/color-functions/get-theme-color/get-theme-color.mjs';\nimport { getContrastColor } from '../../core/MantineProvider/color-functions/get-contrast-color/get-contrast-color.mjs';\nimport '../../core/MantineProvider/Mantine.context.mjs';\nimport '../../core/MantineProvider/default-theme.mjs';\nimport '../../core/MantineProvider/MantineProvider.mjs';\nimport { useMantineTheme } from '../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport { useProps } from '../../core/MantineProvider/use-props/use-props.mjs';\nimport { useStyles } from '../../core/styles-api/use-styles/use-styles.mjs';\nimport { Box } from '../../core/Box/Box.mjs';\nimport { factory } from '../../core/factory/factory.mjs';\nimport { useDirection } from '../../core/DirectionProvider/DirectionProvider.mjs';\nimport { getRootPadding } from './get-root-padding.mjs';\nimport classes from './SegmentedControl.module.css.mjs';\nconst WRAPPER_PADDING = 4;\nconst defaultProps = {\n  withItemsBorders: true\n};\nconst varsResolver = createVarsResolver((theme, _ref) => {\n  let {\n    radius,\n    color,\n    transitionDuration,\n    size,\n    transitionTimingFunction\n  } = _ref;\n  return {\n    root: {\n      \"--sc-radius\": radius === void 0 ? void 0 : getRadius(radius),\n      \"--sc-color\": color ? getThemeColor(color, theme) : void 0,\n      \"--sc-shadow\": color ? void 0 : \"var(--mantine-shadow-xs)\",\n      \"--sc-transition-duration\": transitionDuration === void 0 ? void 0 : \"\".concat(transitionDuration, \"ms\"),\n      \"--sc-transition-timing-function\": transitionTimingFunction,\n      \"--sc-padding\": getSize(size, \"sc-padding\"),\n      \"--sc-font-size\": getFontSize(size)\n    }\n  };\n});\nconst SegmentedControl = factory((_props, ref) => {\n  var _ref2, _data$find$value, _data$find, _data$;\n  const props = useProps(\"SegmentedControl\", defaultProps, _props);\n  const {\n    classNames,\n    className,\n    style,\n    styles,\n    unstyled,\n    vars,\n    data,\n    value,\n    defaultValue,\n    onChange,\n    size,\n    name,\n    disabled,\n    readOnly,\n    fullWidth,\n    orientation,\n    radius,\n    color,\n    transitionDuration,\n    transitionTimingFunction,\n    variant,\n    autoContrast,\n    withItemsBorders,\n    mod,\n    ...others\n  } = props;\n  const getStyles = useStyles({\n    name: \"SegmentedControl\",\n    props,\n    classes,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    varsResolver\n  });\n  const {\n    dir\n  } = useDirection();\n  const theme = useMantineTheme();\n  const _data = data.map(item => typeof item === \"string\" ? {\n    label: item,\n    value: item\n  } : item);\n  const [_value, handleValueChange] = useUncontrolled({\n    value,\n    defaultValue,\n    finalValue: Array.isArray(data) ? (_ref2 = (_data$find$value = (_data$find = _data.find(item => !item.disabled)) === null || _data$find === void 0 ? void 0 : _data$find.value) !== null && _data$find$value !== void 0 ? _data$find$value : (_data$ = data[0]) === null || _data$ === void 0 ? void 0 : _data$.value) !== null && _ref2 !== void 0 ? _ref2 : null : null,\n    onChange\n  });\n  const [activePosition, setActivePosition] = useState({\n    width: 0,\n    height: 0,\n    translate: [0, 0]\n  });\n  const uuid = useId(name);\n  const refs = useRef({});\n  const rootRef = useRef(null);\n  const [initialized, setInitialized] = useState(false);\n  const [observerRef, containerRect] = useResizeObserver();\n  useEffect(() => {\n    if (_value in refs.current && observerRef.current) {\n      const element = refs.current[_value];\n      if (element) {\n        const rootPadding = getRootPadding(rootRef.current, WRAPPER_PADDING);\n        const elementRect = element.getBoundingClientRect();\n        const scaledValue = element.offsetWidth / elementRect.width;\n        const width = element.clientWidth * scaledValue || 0;\n        const height = element.clientHeight * scaledValue || 0;\n        const offsetRight = containerRect.width - element.parentElement.offsetLeft + (dir === \"rtl\" ? rootPadding.left : rootPadding.right) - width;\n        const offsetLeft = element.parentElement.offsetLeft - (dir === \"rtl\" ? rootPadding.right : rootPadding.left);\n        setActivePosition({\n          width,\n          height,\n          translate: [dir === \"rtl\" ? offsetRight * -1 : offsetLeft, element.parentElement.offsetTop - rootPadding.top]\n        });\n      } else {\n        setActivePosition({\n          width: 0,\n          height: 0,\n          translate: [0, 0]\n        });\n      }\n    }\n  }, [_value, containerRect, dir]);\n  useTimeout(() => {\n    if (getEnv() !== \"test\") {\n      setInitialized(true);\n    }\n  }, 20, {\n    autoInvoke: true\n  });\n  const controls = _data.map(item => /* @__PURE__ */React.createElement(Box, {\n    ...getStyles(\"control\"),\n    mod: {\n      active: _value === item.value,\n      orientation\n    },\n    key: item.value\n  }, /* @__PURE__ */React.createElement(\"input\", {\n    ...getStyles(\"input\"),\n    disabled: disabled || item.disabled,\n    type: \"radio\",\n    name: uuid,\n    value: item.value,\n    id: \"\".concat(uuid, \"-\").concat(item.value),\n    checked: _value === item.value,\n    onChange: () => !readOnly && handleValueChange(item.value),\n    \"data-focus-ring\": theme.focusRing\n  }), /* @__PURE__ */React.createElement(Box, {\n    component: \"label\",\n    ...getStyles(\"label\"),\n    mod: {\n      active: _value === item.value && !(disabled || item.disabled),\n      disabled: disabled || item.disabled,\n      \"read-only\": readOnly\n    },\n    htmlFor: \"\".concat(uuid, \"-\").concat(item.value),\n    ref: node => {\n      refs.current[item.value] = node;\n    },\n    __vars: {\n      \"--sc-label-color\": color !== void 0 ? getContrastColor({\n        color,\n        theme\n      }) : void 0\n    }\n  }, item.label)));\n  const mergedRef = useMergedRef(observerRef, rootRef, ref);\n  if (data.length === 0) {\n    return null;\n  }\n  return /* @__PURE__ */React.createElement(Box, {\n    ...getStyles(\"root\"),\n    variant,\n    size,\n    ref: mergedRef,\n    mod: [{\n      \"full-width\": fullWidth,\n      orientation,\n      initialization: !initialized,\n      \"with-items-borders\": withItemsBorders\n    }, mod],\n    ...others,\n    role: \"radiogroup\"\n  }, typeof _value === \"string\" && /* @__PURE__ */React.createElement(Box, {\n    component: \"span\",\n    ...getStyles(\"indicator\"),\n    __vars: {\n      \"--sc-indicator-width\": \"\".concat(activePosition.width, \"px\"),\n      \"--sc-indicator-height\": \"\".concat(activePosition.height, \"px\"),\n      \"--sc-indicator-transform\": \"translate(\".concat(activePosition.translate[0], \"px, \").concat(activePosition.translate[1], \"px)\")\n    }\n  }), controls);\n});\nSegmentedControl.classes = classes;\nSegmentedControl.displayName = \"@mantine/core/SegmentedControl\";\nexport { SegmentedControl };","map":null,"metadata":{},"sourceType":"module"}