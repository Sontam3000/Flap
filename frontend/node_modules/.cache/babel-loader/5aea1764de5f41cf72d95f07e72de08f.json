{"ast":null,"code":"'use client';\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { useId, useUncontrolled, assignRef } from '@mantine/hooks';\nimport { getSize } from '../../core/utils/get-size/get-size.mjs';\nimport { createVarsResolver } from '../../core/styles-api/create-vars-resolver/create-vars-resolver.mjs';\nimport 'clsx';\nimport { useResolvedStylesApi } from '../../core/styles-api/use-resolved-styles-api/use-resolved-styles-api.mjs';\nimport { useStyles } from '../../core/styles-api/use-styles/use-styles.mjs';\nimport '../../core/MantineProvider/Mantine.context.mjs';\nimport '../../core/MantineProvider/default-theme.mjs';\nimport '../../core/MantineProvider/MantineProvider.mjs';\nimport '../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport { useProps } from '../../core/MantineProvider/use-props/use-props.mjs';\nimport '../../core/Box/Box.mjs';\nimport { factory } from '../../core/factory/factory.mjs';\nimport '../../core/DirectionProvider/DirectionProvider.mjs';\nimport { Group } from '../Group/Group.mjs';\nimport { Input } from '../Input/Input.mjs';\nimport '../Input/InputWrapper/InputWrapper.mjs';\nimport '../Input/InputDescription/InputDescription.mjs';\nimport '../Input/InputError/InputError.mjs';\nimport '../Input/InputLabel/InputLabel.mjs';\nimport '../Input/InputPlaceholder/InputPlaceholder.mjs';\nimport '../Input/InputWrapper.context.mjs';\nimport { InputBase } from '../InputBase/InputBase.mjs';\nimport { createPinArray } from './create-pin-array/create-pin-array.mjs';\nimport classes from './PinInput.module.css.mjs';\nconst regex = {\n  number: /^[0-9]+$/,\n  alphanumeric: /^[a-zA-Z0-9]+$/i\n};\nconst defaultProps = {\n  gap: \"sm\",\n  length: 4,\n  manageFocus: true,\n  oneTimeCode: true,\n  placeholder: \"\\u25CB\",\n  type: \"alphanumeric\",\n  ariaLabel: \"PinInput\"\n};\nconst varsResolver = createVarsResolver((_, _ref) => {\n  let {\n    size\n  } = _ref;\n  return {\n    root: {\n      \"--pin-input-size\": getSize(size !== null && size !== void 0 ? size : defaultProps.size, \"pin-input-size\")\n    }\n  };\n});\nconst PinInput = factory((props, ref) => {\n  const {\n    name,\n    form,\n    className,\n    value,\n    defaultValue,\n    variant,\n    gap,\n    style,\n    size,\n    classNames,\n    styles,\n    unstyled,\n    length,\n    onChange,\n    onComplete,\n    manageFocus,\n    autoFocus,\n    error,\n    radius,\n    disabled,\n    oneTimeCode,\n    placeholder,\n    type,\n    mask,\n    readOnly,\n    inputType,\n    inputMode,\n    ariaLabel,\n    vars,\n    id,\n    hiddenInputProps,\n    ...others\n  } = useProps(\"PinInput\", defaultProps, props);\n  const uuid = useId(id);\n  const getStyles = useStyles({\n    name: \"PinInput\",\n    classes,\n    props,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    varsResolver\n  });\n  const {\n    resolvedClassNames,\n    resolvedStyles\n  } = useResolvedStylesApi({\n    classNames,\n    styles,\n    props\n  });\n  const [focusedIndex, setFocusedIndex] = useState(-1);\n  const [_value, setValues] = useUncontrolled({\n    value: value ? createPinArray(length !== null && length !== void 0 ? length : 0, value) : void 0,\n    defaultValue: defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.split(\"\").slice(0, length !== null && length !== void 0 ? length : 0),\n    finalValue: createPinArray(length !== null && length !== void 0 ? length : 0, \"\"),\n    onChange: typeof onChange === \"function\" ? val => {\n      onChange(val.join(\"\").trim());\n    } : void 0\n  });\n  const _valueToString = _value.join(\"\").trim();\n  const inputsRef = useRef([]);\n  const validate = code => {\n    const re = type instanceof RegExp ? type : type && type in regex ? regex[type] : null;\n    return re === null || re === void 0 ? void 0 : re.test(code);\n  };\n  const focusInputField = (dir, index) => {\n    if (!manageFocus) return;\n    if (dir === \"next\") {\n      const nextIndex = index + 1;\n      inputsRef.current[nextIndex < (length !== null && length !== void 0 ? length : 0) ? nextIndex : index].focus();\n    }\n    if (dir === \"prev\") {\n      const nextIndex = index - 1;\n      inputsRef.current[nextIndex > -1 ? nextIndex : index].focus();\n    }\n  };\n  const setFieldValue = (val, index) => {\n    const values = [..._value];\n    values[index] = val;\n    setValues(values);\n  };\n  const handleChange = (event, index) => {\n    const inputValue = event.target.value;\n    const nextCharOrValue = inputValue.length === 2 ? inputValue.split(\"\")[inputValue.length - 1] : inputValue;\n    const isValid = validate(nextCharOrValue);\n    if (nextCharOrValue.length < 2) {\n      if (isValid) {\n        setFieldValue(nextCharOrValue, index);\n        focusInputField(\"next\", index);\n      } else {\n        setFieldValue(\"\", index);\n      }\n    } else if (isValid) {\n      setValues(createPinArray(length !== null && length !== void 0 ? length : 0, inputValue));\n    }\n  };\n  const handleKeyDown = (event, index) => {\n    const {\n      ctrlKey,\n      key,\n      shiftKey,\n      target\n    } = event;\n    const inputValue = target.value;\n    if (inputMode === \"numeric\") {\n      const canTypeSign = key === \"Backspace\" || key === \"Tab\" || key === \"Control\" || key === \"Delete\" || ctrlKey && key === \"v\" ? true : !Number.isNaN(Number(key));\n      if (!canTypeSign) {\n        event.preventDefault();\n      }\n    }\n    if (key === \"ArrowLeft\" || shiftKey && key === \"Tab\") {\n      event.preventDefault();\n      focusInputField(\"prev\", index);\n    } else if (key === \"ArrowRight\" || key === \"Tab\" || key === \" \") {\n      event.preventDefault();\n      focusInputField(\"next\", index);\n    } else if (key === \"Delete\") {\n      event.preventDefault();\n      setFieldValue(\"\", index);\n    } else if (key === \"Backspace\") {\n      event.preventDefault();\n      setFieldValue(\"\", index);\n      if (length === index + 1) {\n        if (event.target.value === \"\") {\n          focusInputField(\"prev\", index);\n        }\n      } else {\n        focusInputField(\"prev\", index);\n      }\n    } else if (inputValue.length > 0 && key === _value[index]) {\n      event.preventDefault();\n      focusInputField(\"next\", index);\n    }\n  };\n  const handleFocus = (event, index) => {\n    event.target.select();\n    setFocusedIndex(index);\n  };\n  const handleBlur = () => {\n    setFocusedIndex(-1);\n  };\n  const handlePaste = event => {\n    event.preventDefault();\n    const copyValue = event.clipboardData.getData(\"text/plain\").replace(/[\\n\\r\\s]+/g, \"\");\n    const isValid = validate(copyValue.trim());\n    if (isValid) {\n      const copyValueToPinArray = createPinArray(length !== null && length !== void 0 ? length : 0, copyValue);\n      setValues(copyValueToPinArray);\n      focusInputField(\"next\", copyValueToPinArray.length - 1);\n    }\n  };\n  useEffect(() => {\n    if (_valueToString.length !== length) return;\n    onComplete === null || onComplete === void 0 ? void 0 : onComplete(_valueToString);\n  }, [length, _valueToString]);\n  useEffect(() => {\n    if (length !== _value.length) {\n      setValues(createPinArray(length !== null && length !== void 0 ? length : 0, _value.join(\"\")));\n    }\n  }, [length, _value]);\n  return /* @__PURE__ */React.createElement(React.Fragment, null, /* @__PURE__ */React.createElement(Group, {\n    ...others,\n    ...getStyles(\"root\"),\n    role: \"group\",\n    id: uuid,\n    gap,\n    unstyled,\n    wrap: \"nowrap\",\n    variant,\n    __size: size\n  }, _value.map((char, index) => /* @__PURE__ */React.createElement(Input, {\n    component: \"input\",\n    ...getStyles(\"pinInput\", {\n      style: {\n        \"--_input-padding\": \"0\",\n        \"--_input-text-align\": \"center\"\n      }\n    }),\n    classNames: resolvedClassNames,\n    styles: resolvedStyles,\n    size,\n    __staticSelector: \"PinInput\",\n    id: \"\".concat(uuid, \"-\").concat(index + 1),\n    key: \"\".concat(uuid, \"-\").concat(index),\n    inputMode: inputMode || (type === \"number\" ? \"numeric\" : \"text\"),\n    onChange: event => handleChange(event, index),\n    onKeyDown: event => handleKeyDown(event, index),\n    onFocus: event => handleFocus(event, index),\n    onBlur: handleBlur,\n    onPaste: handlePaste,\n    type: inputType || (mask ? \"password\" : type === \"number\" ? \"tel\" : \"text\"),\n    radius,\n    error,\n    variant,\n    disabled,\n    ref: node => {\n      index === 0 && assignRef(ref, node);\n      inputsRef.current[index] = node;\n    },\n    autoComplete: oneTimeCode ? \"one-time-code\" : \"off\",\n    placeholder: focusedIndex === index ? \"\" : placeholder,\n    value: char,\n    autoFocus: autoFocus && index === 0,\n    unstyled,\n    \"aria-label\": ariaLabel,\n    readOnly\n  }))), /* @__PURE__ */React.createElement(\"input\", {\n    type: \"hidden\",\n    name,\n    form,\n    value: _valueToString,\n    ...hiddenInputProps\n  }));\n});\nPinInput.classes = {\n  ...classes,\n  ...InputBase.classes\n};\nPinInput.displayName = \"@mantine/core/PinInput\";\nexport { PinInput };","map":null,"metadata":{},"sourceType":"module"}