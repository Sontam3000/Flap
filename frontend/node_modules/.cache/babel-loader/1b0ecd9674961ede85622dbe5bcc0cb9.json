{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@floating-ui/react-dom'), require('react'), require('react-dom')) : typeof define === 'function' && define.amd ? define(['exports', '@floating-ui/react-dom', 'react', 'react-dom'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FloatingUIReact = {}, global.FloatingUIReactDOM, global.React, global.ReactDOM));\n})(this, function (exports, reactDom, React, reactDom$1) {\n  'use strict';\n\n  function _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () {\n              return e[k];\n            }\n          });\n        }\n      });\n    }\n    n.default = e;\n    return Object.freeze(n);\n  }\n  var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n  var index = typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n  let serverHandoffComplete = false;\n  let count = 0;\n  const genId = () => \"floating-ui-\" + count++;\n  function useFloatingId() {\n    const [id, setId] = React__namespace.useState(() => serverHandoffComplete ? genId() : undefined);\n    index(() => {\n      if (id == null) {\n        setId(genId());\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    React__namespace.useEffect(() => {\n      if (!serverHandoffComplete) {\n        serverHandoffComplete = true;\n      }\n    }, []);\n    return id;\n  }\n\n  // `toString()` prevents bundlers from trying to `import { useId } from 'react'`\n  const useReactId = React__namespace[/*#__PURE__*/'useId'.toString()];\n\n  /**\n   * Uses React 18's built-in `useId()` when available, or falls back to a\n   * slightly less performant (requiring a double render) implementation for\n   * earlier React versions.\n   * @see https://floating-ui.com/docs/useId\n   */\n  const useId = useReactId || useFloatingId;\n\n  /**\n   * Renders a pointing arrow triangle.\n   * @see https://floating-ui.com/docs/FloatingArrow\n   */\n  const FloatingArrow = /*#__PURE__*/React__namespace.forwardRef(function FloatingArrow(_ref, ref) {\n    let {\n      context: {\n        placement,\n        elements: {\n          floating\n        },\n        middlewareData: {\n          arrow\n        }\n      },\n      width = 14,\n      height = 7,\n      tipRadius = 0,\n      strokeWidth = 0,\n      staticOffset,\n      stroke,\n      d,\n      style: {\n        transform,\n        ...restStyle\n      } = {},\n      ...rest\n    } = _ref;\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!ref) {\n        console.warn('Floating UI: The `ref` prop is required for the `FloatingArrow`', 'component.');\n      }\n    }\n    const clipPathId = useId();\n    if (!floating) {\n      return null;\n    }\n\n    // Strokes must be double the border width, this ensures the stroke's width\n    // works as you'd expect.\n    strokeWidth *= 2;\n    const halfStrokeWidth = strokeWidth / 2;\n    const svgX = width / 2 * (tipRadius / -8 + 1);\n    const svgY = height / 2 * tipRadius / 4;\n    const [side, alignment] = placement.split('-');\n    const isRTL = reactDom.platform.isRTL(floating);\n    const isCustomShape = !!d;\n    const isVerticalSide = side === 'top' || side === 'bottom';\n    const yOffsetProp = staticOffset && alignment === 'end' ? 'bottom' : 'top';\n    let xOffsetProp = staticOffset && alignment === 'end' ? 'right' : 'left';\n    if (staticOffset && isRTL) {\n      xOffsetProp = alignment === 'end' ? 'left' : 'right';\n    }\n    const arrowX = (arrow == null ? void 0 : arrow.x) != null ? staticOffset || arrow.x : '';\n    const arrowY = (arrow == null ? void 0 : arrow.y) != null ? staticOffset || arrow.y : '';\n    const dValue = d || 'M0,0' + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + ' Z';\n    const rotation = {\n      top: isCustomShape ? 'rotate(180deg)' : '',\n      left: isCustomShape ? 'rotate(90deg)' : 'rotate(-90deg)',\n      bottom: isCustomShape ? '' : 'rotate(180deg)',\n      right: isCustomShape ? 'rotate(-90deg)' : 'rotate(90deg)'\n    }[side];\n    return /*#__PURE__*/React__namespace.createElement(\"svg\", _extends({}, rest, {\n      \"aria-hidden\": true,\n      ref: ref,\n      width: isCustomShape ? width : width + strokeWidth,\n      height: width,\n      viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n      style: {\n        position: 'absolute',\n        pointerEvents: 'none',\n        [xOffsetProp]: arrowX,\n        [yOffsetProp]: arrowY,\n        [side]: isVerticalSide || isCustomShape ? '100%' : \"calc(100% - \" + strokeWidth / 2 + \"px)\",\n        transform: \"\" + rotation + (transform != null ? transform : ''),\n        ...restStyle\n      }\n    }), strokeWidth > 0 && /*#__PURE__*/React__namespace.createElement(\"path\", {\n      clipPath: \"url(#\" + clipPathId + \")\",\n      fill: \"none\",\n      stroke: stroke\n      // Account for the stroke on the fill path rendered below.\n      ,\n\n      strokeWidth: strokeWidth + (d ? 0 : 1),\n      d: dValue\n    }), /*#__PURE__*/React__namespace.createElement(\"path\", {\n      stroke: strokeWidth && !d ? rest.fill : 'none',\n      d: dValue\n    }), /*#__PURE__*/React__namespace.createElement(\"clipPath\", {\n      id: clipPathId\n    }, /*#__PURE__*/React__namespace.createElement(\"rect\", {\n      x: -halfStrokeWidth,\n      y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n      width: width + strokeWidth,\n      height: width\n    })));\n  });\n  function createPubSub() {\n    const map = new Map();\n    return {\n      emit(event, data) {\n        var _map$get;\n        (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach(handler => handler(data));\n      },\n      on(event, listener) {\n        map.set(event, [...(map.get(event) || []), listener]);\n      },\n      off(event, listener) {\n        var _map$get2;\n        map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter(l => l !== listener)) || []);\n      }\n    };\n  }\n  const FloatingNodeContext = /*#__PURE__*/React__namespace.createContext(null);\n  const FloatingTreeContext = /*#__PURE__*/React__namespace.createContext(null);\n  const useFloatingParentNodeId = () => {\n    var _React$useContext;\n    return ((_React$useContext = React__namespace.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n  };\n  const useFloatingTree = () => React__namespace.useContext(FloatingTreeContext);\n\n  /**\n   * Registers a node into the floating tree, returning its id.\n   */\n  function useFloatingNodeId(customParentId) {\n    const id = useId();\n    const tree = useFloatingTree();\n    const reactParentId = useFloatingParentNodeId();\n    const parentId = customParentId || reactParentId;\n    index(() => {\n      const node = {\n        id,\n        parentId\n      };\n      tree == null ? void 0 : tree.addNode(node);\n      return () => {\n        tree == null ? void 0 : tree.removeNode(node);\n      };\n    }, [tree, id, parentId]);\n    return id;\n  }\n\n  /**\n   * Provides parent node context for nested floating elements.\n   * @see https://floating-ui.com/docs/FloatingTree\n   */\n  function FloatingNode(_ref) {\n    let {\n      children,\n      id\n    } = _ref;\n    const parentId = useFloatingParentNodeId();\n    return /*#__PURE__*/React__namespace.createElement(FloatingNodeContext.Provider, {\n      value: React__namespace.useMemo(() => ({\n        id,\n        parentId\n      }), [id, parentId])\n    }, children);\n  }\n\n  /**\n   * Provides context for nested floating elements when they are not children of\n   * each other on the DOM (i.e. portalled to a common node, rather than their\n   * respective parent).\n   * @see https://floating-ui.com/docs/FloatingTree\n   */\n  function FloatingTree(_ref2) {\n    let {\n      children\n    } = _ref2;\n    const nodesRef = React__namespace.useRef([]);\n    const addNode = React__namespace.useCallback(node => {\n      nodesRef.current = [...nodesRef.current, node];\n    }, []);\n    const removeNode = React__namespace.useCallback(node => {\n      nodesRef.current = nodesRef.current.filter(n => n !== node);\n    }, []);\n    const events = React__namespace.useState(() => createPubSub())[0];\n    return /*#__PURE__*/React__namespace.createElement(FloatingTreeContext.Provider, {\n      value: React__namespace.useMemo(() => ({\n        nodesRef,\n        addNode,\n        removeNode,\n        events\n      }), [nodesRef, addNode, removeNode, events])\n    }, children);\n  }\n  function getDocument(node) {\n    return (node == null ? void 0 : node.ownerDocument) || document;\n  }\n\n  // Avoid Chrome DevTools blue warning.\n  function getPlatform() {\n    const uaData = navigator.userAgentData;\n    if (uaData != null && uaData.platform) {\n      return uaData.platform;\n    }\n    return navigator.platform;\n  }\n  function getUserAgent() {\n    const uaData = navigator.userAgentData;\n    if (uaData && Array.isArray(uaData.brands)) {\n      return uaData.brands.map(_ref => {\n        let {\n          brand,\n          version\n        } = _ref;\n        return brand + \"/\" + version;\n      }).join(' ');\n    }\n    return navigator.userAgent;\n  }\n  function getWindow(value) {\n    return getDocument(value).defaultView || window;\n  }\n  function isElement(value) {\n    return value ? value instanceof Element || value instanceof getWindow(value).Element : false;\n  }\n  function isHTMLElement(value) {\n    return value ? value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement : false;\n  }\n  function isShadowRoot(node) {\n    // Browsers without `ShadowRoot` support\n    if (typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n    const OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n  }\n\n  // License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\n  function isVirtualClick(event) {\n    if (event.mozInputSource === 0 && event.isTrusted) {\n      return true;\n    }\n    const androidRe = /Android/i;\n    if ((androidRe.test(getPlatform()) || androidRe.test(getUserAgent())) && event.pointerType) {\n      return event.type === 'click' && event.buttons === 1;\n    }\n    return event.detail === 0 && !event.pointerType;\n  }\n  function isVirtualPointerEvent(event) {\n    return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType !== 'mouse' ||\n    // iOS VoiceOver returns 0.333• for width/height.\n    event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0;\n  }\n  function isSafari() {\n    // Chrome DevTools does not complain about navigator.vendor\n    return /apple/i.test(navigator.vendor);\n  }\n  function isMac() {\n    return getPlatform().toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;\n  }\n  function isMouseLikePointerType(pointerType, strict) {\n    // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n    // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n    const values = ['mouse', 'pen'];\n    if (!strict) {\n      values.push('', undefined);\n    }\n    return values.includes(pointerType);\n  }\n  function isReactEvent(event) {\n    return 'nativeEvent' in event;\n  }\n  function contains(parent, child) {\n    if (!parent || !child) {\n      return false;\n    }\n    const rootNode = child.getRootNode && child.getRootNode();\n\n    // First, attempt with faster native method\n    if (parent.contains(child)) {\n      return true;\n    }\n\n    // then fallback to custom implementation with Shadow DOM support\n    if (rootNode && isShadowRoot(rootNode)) {\n      let next = child;\n      while (next) {\n        if (parent === next) {\n          return true;\n        }\n        // @ts-ignore\n        next = next.parentNode || next.host;\n      }\n    }\n\n    // Give up, the result is false\n    return false;\n  }\n  function createAttribute(name) {\n    return \"data-floating-ui-\" + name;\n  }\n  function useLatestRef(value) {\n    const ref = React.useRef(value);\n    index(() => {\n      ref.current = value;\n    });\n    return ref;\n  }\n  const safePolygonIdentifier = /*#__PURE__*/createAttribute('safe-polygon');\n  function getDelay(value, prop, pointerType) {\n    if (pointerType && !isMouseLikePointerType(pointerType)) {\n      return 0;\n    }\n    if (typeof value === 'number') {\n      return value;\n    }\n    return value == null ? void 0 : value[prop];\n  }\n  /**\n   * Opens the floating element while hovering over the reference element, like\n   * CSS `:hover`.\n   * @see https://floating-ui.com/docs/useHover\n   */\n  function useHover(context, props) {\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      open,\n      onOpenChange,\n      dataRef,\n      events,\n      elements: {\n        domReference,\n        floating\n      },\n      refs\n    } = context;\n    const {\n      enabled = true,\n      delay = 0,\n      handleClose = null,\n      mouseOnly = false,\n      restMs = 0,\n      move = true\n    } = props;\n    const tree = useFloatingTree();\n    const parentId = useFloatingParentNodeId();\n    const handleCloseRef = useLatestRef(handleClose);\n    const delayRef = useLatestRef(delay);\n    const pointerTypeRef = React__namespace.useRef();\n    const timeoutRef = React__namespace.useRef();\n    const handlerRef = React__namespace.useRef();\n    const restTimeoutRef = React__namespace.useRef();\n    const blockMouseMoveRef = React__namespace.useRef(true);\n    const performedPointerEventsMutationRef = React__namespace.useRef(false);\n    const unbindMouseMoveRef = React__namespace.useRef(() => {});\n    const isHoverOpen = React__namespace.useCallback(() => {\n      var _dataRef$current$open;\n      const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n      return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';\n    }, [dataRef]);\n\n    // When dismissing before opening, clear the delay timeouts to cancel it\n    // from showing.\n    React__namespace.useEffect(() => {\n      if (!enabled) {\n        return;\n      }\n      function onDismiss() {\n        clearTimeout(timeoutRef.current);\n        clearTimeout(restTimeoutRef.current);\n        blockMouseMoveRef.current = true;\n      }\n      events.on('dismiss', onDismiss);\n      return () => {\n        events.off('dismiss', onDismiss);\n      };\n    }, [enabled, events]);\n    React__namespace.useEffect(() => {\n      if (!enabled || !handleCloseRef.current || !open) {\n        return;\n      }\n      function onLeave(event) {\n        if (isHoverOpen()) {\n          onOpenChange(false, event);\n        }\n      }\n      const html = getDocument(floating).documentElement;\n      html.addEventListener('mouseleave', onLeave);\n      return () => {\n        html.removeEventListener('mouseleave', onLeave);\n      };\n    }, [floating, open, onOpenChange, enabled, handleCloseRef, dataRef, isHoverOpen]);\n    const closeWithDelay = React__namespace.useCallback(function (event, runElseBranch) {\n      if (runElseBranch === void 0) {\n        runElseBranch = true;\n      }\n      const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);\n      if (closeDelay && !handlerRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = setTimeout(() => onOpenChange(false, event), closeDelay);\n      } else if (runElseBranch) {\n        clearTimeout(timeoutRef.current);\n        onOpenChange(false, event);\n      }\n    }, [delayRef, onOpenChange]);\n    const cleanupMouseMoveHandler = React__namespace.useCallback(() => {\n      unbindMouseMoveRef.current();\n      handlerRef.current = undefined;\n    }, []);\n    const clearPointerEvents = React__namespace.useCallback(() => {\n      if (performedPointerEventsMutationRef.current) {\n        const body = getDocument(refs.floating.current).body;\n        body.style.pointerEvents = '';\n        body.removeAttribute(safePolygonIdentifier);\n        performedPointerEventsMutationRef.current = false;\n      }\n    }, [refs]);\n\n    // Registering the mouse events on the reference directly to bypass React's\n    // delegation system. If the cursor was on a disabled element and then entered\n    // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n    React__namespace.useEffect(() => {\n      if (!enabled) {\n        return;\n      }\n      function isClickLikeOpenEvent() {\n        return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;\n      }\n      function onMouseEnter(event) {\n        clearTimeout(timeoutRef.current);\n        blockMouseMoveRef.current = false;\n        if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, 'open') === 0) {\n          return;\n        }\n        const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);\n        if (openDelay) {\n          timeoutRef.current = setTimeout(() => {\n            onOpenChange(true, event);\n          }, openDelay);\n        } else {\n          onOpenChange(true, event);\n        }\n      }\n      function onMouseLeave(event) {\n        if (isClickLikeOpenEvent()) {\n          return;\n        }\n        unbindMouseMoveRef.current();\n        const doc = getDocument(floating);\n        clearTimeout(restTimeoutRef.current);\n        if (handleCloseRef.current) {\n          // Prevent clearing `onScrollMouseLeave` timeout.\n          if (!open) {\n            clearTimeout(timeoutRef.current);\n          }\n          handlerRef.current = handleCloseRef.current({\n            ...context,\n            tree,\n            x: event.clientX,\n            y: event.clientY,\n            onClose() {\n              clearPointerEvents();\n              cleanupMouseMoveHandler();\n              // Should the event expose that it was closed by `safePolygon`?\n              closeWithDelay(event);\n            }\n          });\n          const handler = handlerRef.current;\n          doc.addEventListener('mousemove', handler);\n          unbindMouseMoveRef.current = () => {\n            doc.removeEventListener('mousemove', handler);\n          };\n          return;\n        }\n\n        // Allow interactivity without `safePolygon` on touch devices. With a\n        // pointer, a short close delay is an alternative, so it should work\n        // consistently.\n        const shouldClose = pointerTypeRef.current === 'touch' ? !contains(floating, event.relatedTarget) : true;\n        if (shouldClose) {\n          closeWithDelay(event);\n        }\n      }\n\n      // Ensure the floating element closes after scrolling even if the pointer\n      // did not move.\n      // https://github.com/floating-ui/floating-ui/discussions/1692\n      function onScrollMouseLeave(event) {\n        if (isClickLikeOpenEvent()) {\n          return;\n        }\n        handleCloseRef.current == null ? void 0 : handleCloseRef.current({\n          ...context,\n          tree,\n          x: event.clientX,\n          y: event.clientY,\n          onClose() {\n            clearPointerEvents();\n            cleanupMouseMoveHandler();\n            closeWithDelay(event);\n          }\n        })(event);\n      }\n      if (isElement(domReference)) {\n        const ref = domReference;\n        open && ref.addEventListener('mouseleave', onScrollMouseLeave);\n        floating == null ? void 0 : floating.addEventListener('mouseleave', onScrollMouseLeave);\n        move && ref.addEventListener('mousemove', onMouseEnter, {\n          once: true\n        });\n        ref.addEventListener('mouseenter', onMouseEnter);\n        ref.addEventListener('mouseleave', onMouseLeave);\n        return () => {\n          open && ref.removeEventListener('mouseleave', onScrollMouseLeave);\n          floating == null ? void 0 : floating.removeEventListener('mouseleave', onScrollMouseLeave);\n          move && ref.removeEventListener('mousemove', onMouseEnter);\n          ref.removeEventListener('mouseenter', onMouseEnter);\n          ref.removeEventListener('mouseleave', onMouseLeave);\n        };\n      }\n    }, [domReference, floating, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, delayRef, handleCloseRef, dataRef]);\n\n    // Block pointer-events of every element other than the reference and floating\n    // while the floating element is open and has a `handleClose` handler. Also\n    // handles nested floating elements.\n    // https://github.com/floating-ui/floating-ui/issues/1722\n    index(() => {\n      var _handleCloseRef$curre;\n      if (!enabled) {\n        return;\n      }\n      if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n        const body = getDocument(floating).body;\n        body.setAttribute(safePolygonIdentifier, '');\n        body.style.pointerEvents = 'none';\n        performedPointerEventsMutationRef.current = true;\n        if (isElement(domReference) && floating) {\n          var _tree$nodesRef$curren, _tree$nodesRef$curren2;\n          const ref = domReference;\n          const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.elements.floating;\n          if (parentFloating) {\n            parentFloating.style.pointerEvents = '';\n          }\n          ref.style.pointerEvents = 'auto';\n          floating.style.pointerEvents = 'auto';\n          return () => {\n            ref.style.pointerEvents = '';\n            floating.style.pointerEvents = '';\n          };\n        }\n      }\n    }, [enabled, open, parentId, floating, domReference, tree, handleCloseRef, dataRef, isHoverOpen]);\n    index(() => {\n      if (!open) {\n        pointerTypeRef.current = undefined;\n        cleanupMouseMoveHandler();\n        clearPointerEvents();\n      }\n    }, [open, cleanupMouseMoveHandler, clearPointerEvents]);\n    React__namespace.useEffect(() => {\n      return () => {\n        cleanupMouseMoveHandler();\n        clearTimeout(timeoutRef.current);\n        clearTimeout(restTimeoutRef.current);\n        clearPointerEvents();\n      };\n    }, [enabled, cleanupMouseMoveHandler, clearPointerEvents]);\n    return React__namespace.useMemo(() => {\n      if (!enabled) {\n        return {};\n      }\n      function setPointerRef(event) {\n        pointerTypeRef.current = event.pointerType;\n      }\n      return {\n        reference: {\n          onPointerDown: setPointerRef,\n          onPointerEnter: setPointerRef,\n          onMouseMove(event) {\n            if (open || restMs === 0) {\n              return;\n            }\n            clearTimeout(restTimeoutRef.current);\n            restTimeoutRef.current = setTimeout(() => {\n              if (!blockMouseMoveRef.current) {\n                onOpenChange(true, event.nativeEvent);\n              }\n            }, restMs);\n          }\n        },\n        floating: {\n          onMouseEnter() {\n            clearTimeout(timeoutRef.current);\n          },\n          onMouseLeave(event) {\n            events.emit('dismiss', {\n              type: 'mouseLeave',\n              data: {\n                returnFocus: false\n              }\n            });\n            closeWithDelay(event.nativeEvent, false);\n          }\n        }\n      };\n    }, [events, enabled, restMs, open, onOpenChange, closeWithDelay]);\n  }\n  const FloatingDelayGroupContext = /*#__PURE__*/React__namespace.createContext({\n    delay: 0,\n    initialDelay: 0,\n    timeoutMs: 0,\n    currentId: null,\n    setCurrentId: () => {},\n    setState: () => {},\n    isInstantPhase: false\n  });\n  const useDelayGroupContext = () => React__namespace.useContext(FloatingDelayGroupContext);\n  /**\n   * Provides context for a group of floating elements that should share a\n   * `delay`.\n   * @see https://floating-ui.com/docs/FloatingDelayGroup\n   */\n  const FloatingDelayGroup = _ref => {\n    let {\n      children,\n      delay,\n      timeoutMs = 0\n    } = _ref;\n    const [state, setState] = React__namespace.useReducer((prev, next) => ({\n      ...prev,\n      ...next\n    }), {\n      delay,\n      timeoutMs,\n      initialDelay: delay,\n      currentId: null,\n      isInstantPhase: false\n    });\n    const initialCurrentIdRef = React__namespace.useRef(null);\n    const setCurrentId = React__namespace.useCallback(currentId => {\n      setState({\n        currentId\n      });\n    }, []);\n    index(() => {\n      if (state.currentId) {\n        if (initialCurrentIdRef.current === null) {\n          initialCurrentIdRef.current = state.currentId;\n        } else {\n          setState({\n            isInstantPhase: true\n          });\n        }\n      } else {\n        setState({\n          isInstantPhase: false\n        });\n        initialCurrentIdRef.current = null;\n      }\n    }, [state.currentId]);\n    return /*#__PURE__*/React__namespace.createElement(FloatingDelayGroupContext.Provider, {\n      value: React__namespace.useMemo(() => ({\n        ...state,\n        setState,\n        setCurrentId\n      }), [state, setState, setCurrentId])\n    }, children);\n  };\n  const useDelayGroup = (_ref2, _ref3) => {\n    let {\n      open,\n      onOpenChange\n    } = _ref2;\n    let {\n      id\n    } = _ref3;\n    const {\n      currentId,\n      setCurrentId,\n      initialDelay,\n      setState,\n      timeoutMs\n    } = useDelayGroupContext();\n    index(() => {\n      if (currentId) {\n        setState({\n          delay: {\n            open: 1,\n            close: getDelay(initialDelay, 'close')\n          }\n        });\n        if (currentId !== id) {\n          onOpenChange(false);\n        }\n      }\n    }, [id, onOpenChange, setState, currentId, initialDelay]);\n    index(() => {\n      function unset() {\n        onOpenChange(false);\n        setState({\n          delay: initialDelay,\n          currentId: null\n        });\n      }\n      if (!open && currentId === id) {\n        if (timeoutMs) {\n          const timeout = window.setTimeout(unset, timeoutMs);\n          return () => {\n            clearTimeout(timeout);\n          };\n        } else {\n          unset();\n        }\n      }\n    }, [open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);\n    index(() => {\n      if (open) {\n        setCurrentId(id);\n      }\n    }, [open, setCurrentId, id]);\n  };\n  var getDefaultParent = function (originalTarget) {\n    if (typeof document === 'undefined') {\n      return null;\n    }\n    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;\n    return sampleTarget.ownerDocument.body;\n  };\n  var counterMap = new WeakMap();\n  var uncontrolledNodes = new WeakMap();\n  var markerMap = {};\n  var lockCount = 0;\n  var unwrapHost = function (node) {\n    return node && (node.host || unwrapHost(node.parentNode));\n  };\n  var correctTargets = function (parent, targets) {\n    return targets.map(function (target) {\n      if (parent.contains(target)) {\n        return target;\n      }\n      var correctedTarget = unwrapHost(target);\n      if (correctedTarget && parent.contains(correctedTarget)) {\n        return correctedTarget;\n      }\n      console.error('aria-hidden', target, 'in not contained inside', parent, '. Doing nothing');\n      return null;\n    }).filter(function (x) {\n      return Boolean(x);\n    });\n  };\n  /**\n   * Marks everything except given node(or nodes) as aria-hidden\n   * @param {Element | Element[]} originalTarget - elements to keep on the page\n   * @param [parentNode] - top element, defaults to document.body\n   * @param {String} [markerName] - a special attribute to mark every node\n   * @param {String} [controlAttribute] - html Attribute to control\n   * @return {Undo} undo command\n   */\n  var applyAttributeToOthers = function (originalTarget, parentNode, markerName, controlAttribute) {\n    var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n    if (!markerMap[markerName]) {\n      markerMap[markerName] = new WeakMap();\n    }\n    var markerCounter = markerMap[markerName];\n    var hiddenNodes = [];\n    var elementsToKeep = new Set();\n    var elementsToStop = new Set(targets);\n    var keep = function (el) {\n      if (!el || elementsToKeep.has(el)) {\n        return;\n      }\n      elementsToKeep.add(el);\n      keep(el.parentNode);\n    };\n    targets.forEach(keep);\n    var deep = function (parent) {\n      if (!parent || elementsToStop.has(parent)) {\n        return;\n      }\n      Array.prototype.forEach.call(parent.children, function (node) {\n        if (elementsToKeep.has(node)) {\n          deep(node);\n        } else {\n          var attr = node.getAttribute(controlAttribute);\n          var alreadyHidden = attr !== null && attr !== 'false';\n          var counterValue = (counterMap.get(node) || 0) + 1;\n          var markerValue = (markerCounter.get(node) || 0) + 1;\n          counterMap.set(node, counterValue);\n          markerCounter.set(node, markerValue);\n          hiddenNodes.push(node);\n          if (counterValue === 1 && alreadyHidden) {\n            uncontrolledNodes.set(node, true);\n          }\n          if (markerValue === 1) {\n            node.setAttribute(markerName, 'true');\n          }\n          if (!alreadyHidden) {\n            node.setAttribute(controlAttribute, 'true');\n          }\n        }\n      });\n    };\n    deep(parentNode);\n    elementsToKeep.clear();\n    lockCount++;\n    return function () {\n      hiddenNodes.forEach(function (node) {\n        var counterValue = counterMap.get(node) - 1;\n        var markerValue = markerCounter.get(node) - 1;\n        counterMap.set(node, counterValue);\n        markerCounter.set(node, markerValue);\n        if (!counterValue) {\n          if (!uncontrolledNodes.has(node)) {\n            node.removeAttribute(controlAttribute);\n          }\n          uncontrolledNodes.delete(node);\n        }\n        if (!markerValue) {\n          node.removeAttribute(markerName);\n        }\n      });\n      lockCount--;\n      if (!lockCount) {\n        // clear\n        counterMap = new WeakMap();\n        counterMap = new WeakMap();\n        uncontrolledNodes = new WeakMap();\n        markerMap = {};\n      }\n    };\n  };\n  /**\n   * Marks everything except given node(or nodes) as aria-hidden\n   * @param {Element | Element[]} originalTarget - elements to keep on the page\n   * @param [parentNode] - top element, defaults to document.body\n   * @param {String} [markerName] - a special attribute to mark every node\n   * @return {Undo} undo command\n   */\n  var hideOthers = function (originalTarget, parentNode, markerName) {\n    if (markerName === void 0) {\n      markerName = 'data-aria-hidden';\n    }\n    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n    var activeParentNode = parentNode || getDefaultParent(originalTarget);\n    if (!activeParentNode) {\n      return function () {\n        return null;\n      };\n    }\n    // we should not hide ariaLive elements - https://github.com/theKashey/aria-hidden/issues/10\n    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll('[aria-live]')));\n    return applyAttributeToOthers(targets, activeParentNode, markerName, 'aria-hidden');\n  };\n  /**\n   * Marks everything except given node(or nodes) as inert\n   * @param {Element | Element[]} originalTarget - elements to keep on the page\n   * @param [parentNode] - top element, defaults to document.body\n   * @param {String} [markerName] - a special attribute to mark every node\n   * @return {Undo} undo command\n   */\n  var inertOthers = function (originalTarget, parentNode, markerName) {\n    if (markerName === void 0) {\n      markerName = 'data-inert-ed';\n    }\n    var activeParentNode = parentNode || getDefaultParent(originalTarget);\n    if (!activeParentNode) {\n      return function () {\n        return null;\n      };\n    }\n    return applyAttributeToOthers(originalTarget, activeParentNode, markerName, 'inert');\n  };\n  /**\n   * @returns if current browser supports inert\n   */\n  var supportsInert = function () {\n    return typeof HTMLElement !== 'undefined' && HTMLElement.prototype.hasOwnProperty('inert');\n  };\n  /**\n   * Automatic function to \"suppress\" DOM elements - _hide_ or _inert_ in the best possible way\n   * @param {Element | Element[]} originalTarget - elements to keep on the page\n   * @param [parentNode] - top element, defaults to document.body\n   * @param {String} [markerName] - a special attribute to mark every node\n   * @return {Undo} undo command\n   */\n  var suppressOthers = function (originalTarget, parentNode, markerName) {\n    if (markerName === void 0) {\n      markerName = 'data-suppressed';\n    }\n    return (supportsInert() ? inertOthers : hideOthers)(originalTarget, parentNode, markerName);\n  };\n\n  /*!\n  * tabbable 6.0.1\n  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n  */\n  var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])', 'details>summary:first-of-type', 'details'];\n  var candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\n  var NoElement = typeof Element === 'undefined';\n  var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n  var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n    return element.getRootNode();\n  } : function (element) {\n    return element.ownerDocument;\n  };\n\n  /**\n   * @param {Element} el container to check in\n   * @param {boolean} includeContainer add container to check\n   * @param {(node: Element) => boolean} filter filter candidates\n   * @returns {Element[]}\n   */\n  var getCandidates = function getCandidates(el, includeContainer, filter) {\n    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n    if (includeContainer && matches.call(el, candidateSelector)) {\n      candidates.unshift(el);\n    }\n    candidates = candidates.filter(filter);\n    return candidates;\n  };\n\n  /**\n   * @callback GetShadowRoot\n   * @param {Element} element to check for shadow root\n   * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n   */\n\n  /**\n   * @callback ShadowRootFilter\n   * @param {Element} shadowHostNode the element which contains shadow content\n   * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n   */\n\n  /**\n   * @typedef {Object} CandidateScope\n   * @property {Element} scopeParent contains inner candidates\n   * @property {Element[]} candidates list of candidates found in the scope parent\n   */\n\n  /**\n   * @typedef {Object} IterativeOptions\n   * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n   *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n   *  or a boolean stating if it has an undisclosed shadow root\n   * @property {(node: Element) => boolean} filter filter candidates\n   * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n   * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n   */\n\n  /**\n   * @param {Element[]} elements list of element containers to match candidates from\n   * @param {boolean} includeContainer add container list to check\n   * @param {IterativeOptions} options\n   * @returns {Array.<Element|CandidateScope>}\n   */\n  var getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n    var candidates = [];\n    var elementsToCheck = Array.from(elements);\n    while (elementsToCheck.length) {\n      var element = elementsToCheck.shift();\n      if (element.tagName === 'SLOT') {\n        // add shadow dom slot scope (slot itself cannot be focusable)\n        var assigned = element.assignedElements();\n        var content = assigned.length ? assigned : element.children;\n        var nestedCandidates = getCandidatesIteratively(content, true, options);\n        if (options.flatten) {\n          candidates.push.apply(candidates, nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: nestedCandidates\n          });\n        }\n      } else {\n        // check candidate element\n        var validCandidate = matches.call(element, candidateSelector);\n        if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n          candidates.push(element);\n        }\n\n        // iterate over shadow content if possible\n        var shadowRoot = element.shadowRoot ||\n        // check for an undisclosed shadow\n        typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n        var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);\n        if (shadowRoot && validShadowRoot) {\n          // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n          //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n          //  child candidates found because they're likely slotted elements (elements that are\n          //  children of the web component element (which has the shadow), in the light dom, but\n          //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n          //  _after_ we return from this recursive call\n          var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n          if (options.flatten) {\n            candidates.push.apply(candidates, _nestedCandidates);\n          } else {\n            candidates.push({\n              scopeParent: element,\n              candidates: _nestedCandidates\n            });\n          }\n        } else {\n          // there's not shadow so just dig into the element's (light dom) children\n          //  __without__ giving the element special scope treatment\n          elementsToCheck.unshift.apply(elementsToCheck, element.children);\n        }\n      }\n    }\n    return candidates;\n  };\n  var getTabindex = function getTabindex(node, isScope) {\n    if (node.tabIndex < 0) {\n      // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n      // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n      // yet they are still part of the regular tab order; in FF, they get a default\n      // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n      // order, consider their tab index to be 0.\n      // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n      // so if they don't have a tabindex attribute specifically set, assume it's 0.\n      //\n      // isScope is positive for custom element with shadow root or slot that by default\n      // have tabIndex -1, but need to be sorted by document order in order for their\n      // content to be inserted in the correct position\n      if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute('tabindex'), 10))) {\n        return 0;\n      }\n    }\n    return node.tabIndex;\n  };\n  var sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n    return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n  };\n  var isInput = function isInput(node) {\n    return node.tagName === 'INPUT';\n  };\n  var isHiddenInput = function isHiddenInput(node) {\n    return isInput(node) && node.type === 'hidden';\n  };\n  var isDetailsWithSummary = function isDetailsWithSummary(node) {\n    var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n      return child.tagName === 'SUMMARY';\n    });\n    return r;\n  };\n  var getCheckedRadio = function getCheckedRadio(nodes, form) {\n    for (var i = 0; i < nodes.length; i++) {\n      if (nodes[i].checked && nodes[i].form === form) {\n        return nodes[i];\n      }\n    }\n  };\n  var isTabbableRadio = function isTabbableRadio(node) {\n    if (!node.name) {\n      return true;\n    }\n    var radioScope = node.form || getRootNode(node);\n    var queryRadios = function queryRadios(name) {\n      return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n    };\n    var radioSet;\n    if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n      radioSet = queryRadios(window.CSS.escape(node.name));\n    } else {\n      try {\n        radioSet = queryRadios(node.name);\n      } catch (err) {\n        // eslint-disable-next-line no-console\n        console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n        return false;\n      }\n    }\n    var checked = getCheckedRadio(radioSet, node.form);\n    return !checked || checked === node;\n  };\n  var isRadio = function isRadio(node) {\n    return isInput(node) && node.type === 'radio';\n  };\n  var isNonTabbableRadio = function isNonTabbableRadio(node) {\n    return isRadio(node) && !isTabbableRadio(node);\n  };\n\n  // determines if a node is ultimately attached to the window's document\n  var isNodeAttached = function isNodeAttached(node) {\n    var _nodeRootHost;\n    // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n    //  (but NOT _the_ document; see second 'If' comment below for more).\n    // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n    //  is attached, and the one we need to check if it's in the document or not (because the\n    //  shadow, and all nodes it contains, is never considered in the document since shadows\n    //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n    //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n    //  visibility, including all the nodes it contains). The host could be any normal node,\n    //  or a custom element (i.e. web component). Either way, that's the one that is considered\n    //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n    //  tested).\n    // To further complicate things, we have to look all the way up until we find a shadow HOST\n    //  that is attached (or find none) because the node might be in nested shadows...\n    // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n    //  document (per the docs) and while it's a Document-type object, that document does not\n    //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n    //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n    //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n    //  node is actually detached.\n    var nodeRootHost = getRootNode(node).host;\n    var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));\n    while (!attached && nodeRootHost) {\n      var _nodeRootHost2;\n      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n      //  which means we need to get the host's host and check if that parent host is contained\n      //  in (i.e. attached to) the document\n      nodeRootHost = getRootNode(nodeRootHost).host;\n      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));\n    }\n    return attached;\n  };\n  var isZeroArea = function isZeroArea(node) {\n    var _node$getBoundingClie = node.getBoundingClientRect(),\n      width = _node$getBoundingClie.width,\n      height = _node$getBoundingClie.height;\n    return width === 0 && height === 0;\n  };\n  var isHidden = function isHidden(node, _ref) {\n    var displayCheck = _ref.displayCheck,\n      getShadowRoot = _ref.getShadowRoot;\n    // NOTE: visibility will be `undefined` if node is detached from the document\n    //  (see notes about this further down), which means we will consider it visible\n    //  (this is legacy behavior from a very long way back)\n    // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n    //  _visibility_ check, not a _display_ check\n    if (getComputedStyle(node).visibility === 'hidden') {\n      return true;\n    }\n    var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n    if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n      return true;\n    }\n    if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {\n      if (typeof getShadowRoot === 'function') {\n        // figure out if we should consider the node to be in an undisclosed shadow and use the\n        //  'non-zero-area' fallback\n        var originalNode = node;\n        while (node) {\n          var parentElement = node.parentElement;\n          var rootNode = getRootNode(node);\n          if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n          ) {\n            // node has an undisclosed shadow which means we can only treat it as a black box, so we\n            //  fall back to a non-zero-area test\n            return isZeroArea(node);\n          } else if (node.assignedSlot) {\n            // iterate up slot\n            node = node.assignedSlot;\n          } else if (!parentElement && rootNode !== node.ownerDocument) {\n            // cross shadow boundary\n            node = rootNode.host;\n          } else {\n            // iterate up normal dom\n            node = parentElement;\n          }\n        }\n        node = originalNode;\n      }\n      // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n      //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n      //  it might be a falsy value, which means shadow DOM support is disabled\n\n      // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n      //  now we can just test to see if it would normally be visible or not, provided it's\n      //  attached to the main document.\n      // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n      //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n      if (isNodeAttached(node)) {\n        // this works wherever the node is: if there's at least one client rect, it's\n        //  somehow displayed; it also covers the CSS 'display: contents' case where the\n        //  node itself is hidden in place of its contents; and there's no need to search\n        //  up the hierarchy either\n        return !node.getClientRects().length;\n      }\n\n      // Else, the node isn't attached to the document, which means the `getClientRects()`\n      //  API will __always__ return zero rects (this can happen, for example, if React\n      //  is used to render nodes onto a detached tree, as confirmed in this thread:\n      //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n      //\n      // It also means that even window.getComputedStyle(node).display will return `undefined`\n      //  because styles are only computed for nodes that are in the document.\n      //\n      // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n      //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n      //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n      //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n      //  considering __everything__ to be visible because of the innability to determine styles.\n      //\n      // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n      //  nodes as visible with the 'none' fallback.__\n      if (displayCheck !== 'legacy-full') {\n        return true; // hidden\n      }\n      // else, fallback to 'none' mode and consider the node visible\n    } else if (displayCheck === 'non-zero-area') {\n      // NOTE: Even though this tests that the node's client rect is non-zero to determine\n      //  whether it's displayed, and that a detached node will __always__ have a zero-area\n      //  client rect, we don't special-case for whether the node is attached or not. In\n      //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n      //  times, and that includes attached or not.\n      return isZeroArea(node);\n    }\n\n    // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n    //  it's visible\n    return false;\n  };\n\n  // form fields (nested) inside a disabled fieldset are not focusable/tabbable\n  //  unless they are in the _first_ <legend> element of the top-most disabled\n  //  fieldset\n  var isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n      var parentNode = node.parentElement;\n      // check if `node` is contained in a disabled <fieldset>\n      while (parentNode) {\n        if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n          // look for the first <legend> among the children of the disabled <fieldset>\n          for (var i = 0; i < parentNode.children.length; i++) {\n            var child = parentNode.children.item(i);\n            // when the first <legend> (in document order) is found\n            if (child.tagName === 'LEGEND') {\n              // if its parent <fieldset> is not nested in another disabled <fieldset>,\n              // return whether `node` is a descendant of its first <legend>\n              return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n            }\n          }\n          // the disabled <fieldset> containing `node` has no <legend>\n          return true;\n        }\n        parentNode = parentNode.parentElement;\n      }\n    }\n\n    // else, node's tabbable/focusable state should not be affected by a fieldset's\n    //  enabled/disabled state\n    return false;\n  };\n  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n    if (node.disabled || isHiddenInput(node) || isHidden(node, options) ||\n    // For a details element with a summary, the summary element gets the focus\n    isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n      return false;\n    }\n    return true;\n  };\n  var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n    if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n      return false;\n    }\n    return true;\n  };\n  var isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n    var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n    if (isNaN(tabIndex) || tabIndex >= 0) {\n      return true;\n    }\n    // If a custom element has an explicit negative tabindex,\n    // browsers will not allow tab targeting said element's children.\n    return false;\n  };\n\n  /**\n   * @param {Array.<Element|CandidateScope>} candidates\n   * @returns Element[]\n   */\n  var sortByOrder = function sortByOrder(candidates) {\n    var regularTabbables = [];\n    var orderedTabbables = [];\n    candidates.forEach(function (item, i) {\n      var isScope = !!item.scopeParent;\n      var element = isScope ? item.scopeParent : item;\n      var candidateTabindex = getTabindex(element, isScope);\n      var elements = isScope ? sortByOrder(item.candidates) : element;\n      if (candidateTabindex === 0) {\n        isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n      } else {\n        orderedTabbables.push({\n          documentOrder: i,\n          tabIndex: candidateTabindex,\n          item: item,\n          isScope: isScope,\n          content: elements\n        });\n      }\n    });\n    return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n      sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n      return acc;\n    }, []).concat(regularTabbables);\n  };\n  var tabbable = function tabbable(el, options) {\n    options = options || {};\n    var candidates;\n    if (options.getShadowRoot) {\n      candidates = getCandidatesIteratively([el], options.includeContainer, {\n        filter: isNodeMatchingSelectorTabbable.bind(null, options),\n        flatten: false,\n        getShadowRoot: options.getShadowRoot,\n        shadowRootFilter: isValidShadowRootTabbable\n      });\n    } else {\n      candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n    }\n    return sortByOrder(candidates);\n  };\n\n  /**\n   * Find the real active element. Traverses into shadowRoots.\n   */\n  function activeElement(doc) {\n    let activeElement = doc.activeElement;\n    while (((_activeElement = activeElement) == null ? void 0 : (_activeElement$shadow = _activeElement.shadowRoot) == null ? void 0 : _activeElement$shadow.activeElement) != null) {\n      var _activeElement, _activeElement$shadow;\n      activeElement = activeElement.shadowRoot.activeElement;\n    }\n    return activeElement;\n  }\n  let rafId = 0;\n  function enqueueFocus(el, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const {\n      preventScroll = false,\n      cancelPrevious = true,\n      sync = false\n    } = options;\n    cancelPrevious && cancelAnimationFrame(rafId);\n    const exec = () => el == null ? void 0 : el.focus({\n      preventScroll\n    });\n    if (sync) {\n      exec();\n    } else {\n      rafId = requestAnimationFrame(exec);\n    }\n  }\n  function getAncestors(nodes, id) {\n    var _nodes$find;\n    let allAncestors = [];\n    let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;\n    while (currentParentId) {\n      const currentNode = nodes.find(node => node.id === currentParentId);\n      currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n      if (currentNode) {\n        allAncestors = allAncestors.concat(currentNode);\n      }\n    }\n    return allAncestors;\n  }\n  function getChildren(nodes, id) {\n    let allChildren = nodes.filter(node => {\n      var _node$context;\n      return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n    });\n    let currentChildren = allChildren;\n    while (currentChildren.length) {\n      currentChildren = nodes.filter(node => {\n        var _currentChildren;\n        return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {\n          var _node$context2;\n          return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n        });\n      });\n      allChildren = allChildren.concat(currentChildren);\n    }\n    return allChildren;\n  }\n  function getTarget(event) {\n    if ('composedPath' in event) {\n      return event.composedPath()[0];\n    }\n\n    // TS thinks `event` is of type never as it assumes all browsers support\n    // `composedPath()`, but browsers without shadow DOM don't.\n    return event.target;\n  }\n  const TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\n  function isTypeableElement(element) {\n    return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n  }\n  function stopEvent(event) {\n    event.preventDefault();\n    event.stopPropagation();\n  }\n  const getTabbableOptions = () => ({\n    getShadowRoot: true,\n    displayCheck:\n    // JSDOM does not support the `tabbable` library. To solve this we can\n    // check if `ResizeObserver` is a real function (not polyfilled), which\n    // determines if the current environment is JSDOM-like.\n    typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'\n  });\n  function getTabbableIn(container, direction) {\n    const allTabbable = tabbable(container, getTabbableOptions());\n    if (direction === 'prev') {\n      allTabbable.reverse();\n    }\n    const activeIndex = allTabbable.indexOf(activeElement(getDocument(container)));\n    const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n    return nextTabbableElements[0];\n  }\n  function getNextTabbable() {\n    return getTabbableIn(document.body, 'next');\n  }\n  function getPreviousTabbable() {\n    return getTabbableIn(document.body, 'prev');\n  }\n  function isOutsideEvent(event, container) {\n    const containerElement = container || event.currentTarget;\n    const relatedTarget = event.relatedTarget;\n    return !relatedTarget || !contains(containerElement, relatedTarget);\n  }\n  function disableFocusInside(container) {\n    const tabbableElements = tabbable(container, getTabbableOptions());\n    tabbableElements.forEach(element => {\n      element.dataset.tabindex = element.getAttribute('tabindex') || '';\n      element.setAttribute('tabindex', '-1');\n    });\n  }\n  function enableFocusInside(container) {\n    const elements = container.querySelectorAll('[data-tabindex]');\n    elements.forEach(element => {\n      const tabindex = element.dataset.tabindex;\n      delete element.dataset.tabindex;\n      if (tabindex) {\n        element.setAttribute('tabindex', tabindex);\n      } else {\n        element.removeAttribute('tabindex');\n      }\n    });\n  }\n\n  // See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n  // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\n\n  const HIDDEN_STYLES = {\n    border: 0,\n    clip: 'rect(0 0 0 0)',\n    height: '1px',\n    margin: '-1px',\n    overflow: 'hidden',\n    padding: 0,\n    position: 'fixed',\n    whiteSpace: 'nowrap',\n    width: '1px',\n    top: 0,\n    left: 0\n  };\n  let timeoutId;\n  function setActiveElementOnTab(event) {\n    if (event.key === 'Tab') {\n      event.target;\n      clearTimeout(timeoutId);\n    }\n  }\n  const FocusGuard = /*#__PURE__*/React__namespace.forwardRef(function FocusGuard(props, ref) {\n    const [role, setRole] = React__namespace.useState();\n    index(() => {\n      if (isSafari()) {\n        // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n        // on VoiceOver does trigger the onFocus event, so we can use the focus\n        // trap element. On Safari, only buttons trigger the onFocus event.\n        // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n        // button role.\n        setRole('button');\n      }\n      document.addEventListener('keydown', setActiveElementOnTab);\n      return () => {\n        document.removeEventListener('keydown', setActiveElementOnTab);\n      };\n    }, []);\n    const restProps = {\n      ref,\n      tabIndex: 0,\n      // Role is only for VoiceOver\n      role,\n      'aria-hidden': role ? undefined : true,\n      [createAttribute('focus-guard')]: '',\n      style: HIDDEN_STYLES\n    };\n    return /*#__PURE__*/React__namespace.createElement(\"span\", _extends({}, props, restProps));\n  });\n  const PortalContext = /*#__PURE__*/React__namespace.createContext(null);\n  function useFloatingPortalNode(_temp) {\n    let {\n      id,\n      root\n    } = _temp === void 0 ? {} : _temp;\n    const [portalNode, setPortalNode] = React__namespace.useState(null);\n    const uniqueId = useId();\n    const portalContext = usePortalContext();\n    const data = React__namespace.useMemo(() => ({\n      id,\n      root,\n      portalContext,\n      uniqueId\n    }), [id, root, portalContext, uniqueId]);\n    const dataRef = React__namespace.useRef();\n    index(() => {\n      return () => {\n        portalNode == null ? void 0 : portalNode.remove();\n      };\n    }, [portalNode, data]);\n    index(() => {\n      if (dataRef.current === data) return;\n      dataRef.current = data;\n      const {\n        id,\n        root,\n        portalContext,\n        uniqueId\n      } = data;\n      const existingIdRoot = id ? document.getElementById(id) : null;\n      const attr = createAttribute('portal');\n      if (existingIdRoot) {\n        const subRoot = document.createElement('div');\n        subRoot.id = uniqueId;\n        subRoot.setAttribute(attr, '');\n        existingIdRoot.appendChild(subRoot);\n        setPortalNode(subRoot);\n      } else {\n        let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n        if (container && !isElement(container)) container = container.current;\n        container = container || document.body;\n        let idWrapper = null;\n        if (id) {\n          idWrapper = document.createElement('div');\n          idWrapper.id = id;\n          container.appendChild(idWrapper);\n        }\n        const subRoot = document.createElement('div');\n        subRoot.id = uniqueId;\n        subRoot.setAttribute(attr, '');\n        container = idWrapper || container;\n        container.appendChild(subRoot);\n        setPortalNode(subRoot);\n      }\n    }, [data]);\n    return portalNode;\n  }\n  /**\n   * Portals the floating element into a given container element — by default,\n   * outside of the app root and into the body.\n   * @see https://floating-ui.com/docs/FloatingPortal\n   */\n  function FloatingPortal(_ref) {\n    let {\n      children,\n      id,\n      root = null,\n      preserveTabOrder = true\n    } = _ref;\n    const portalNode = useFloatingPortalNode({\n      id,\n      root\n    });\n    const [focusManagerState, setFocusManagerState] = React__namespace.useState(null);\n    const beforeOutsideRef = React__namespace.useRef(null);\n    const afterOutsideRef = React__namespace.useRef(null);\n    const beforeInsideRef = React__namespace.useRef(null);\n    const afterInsideRef = React__namespace.useRef(null);\n    const shouldRenderGuards =\n    // The FocusManager and therefore floating element are currently open/\n    // rendered.\n    !!focusManagerState &&\n    // Guards are only for non-modal focus management.\n    !focusManagerState.modal &&\n    // Don't render if unmount is transitioning.\n    focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n\n    // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n    React__namespace.useEffect(() => {\n      if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n        return;\n      }\n\n      // Make sure elements inside the portal element are tabbable only when the\n      // portal has already been focused, either by tabbing into a focus trap\n      // element outside or using the mouse.\n      function onFocus(event) {\n        if (portalNode && isOutsideEvent(event)) {\n          const focusing = event.type === 'focusin';\n          const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n          manageFocus(portalNode);\n        }\n      }\n      // Listen to the event on the capture phase so they run before the focus\n      // trap elements onFocus prop is called.\n      portalNode.addEventListener('focusin', onFocus, true);\n      portalNode.addEventListener('focusout', onFocus, true);\n      return () => {\n        portalNode.removeEventListener('focusin', onFocus, true);\n        portalNode.removeEventListener('focusout', onFocus, true);\n      };\n    }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);\n    return /*#__PURE__*/React__namespace.createElement(PortalContext.Provider, {\n      value: React__namespace.useMemo(() => ({\n        preserveTabOrder,\n        beforeOutsideRef,\n        afterOutsideRef,\n        beforeInsideRef,\n        afterInsideRef,\n        portalNode,\n        setFocusManagerState\n      }), [preserveTabOrder, portalNode])\n    }, shouldRenderGuards && portalNode && /*#__PURE__*/React__namespace.createElement(FocusGuard, {\n      \"data-type\": \"outside\",\n      ref: beforeOutsideRef,\n      onFocus: event => {\n        if (isOutsideEvent(event, portalNode)) {\n          var _beforeInsideRef$curr;\n          (_beforeInsideRef$curr = beforeInsideRef.current) == null ? void 0 : _beforeInsideRef$curr.focus();\n        } else {\n          const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n          prevTabbable == null ? void 0 : prevTabbable.focus();\n        }\n      }\n    }), shouldRenderGuards && portalNode && /*#__PURE__*/React__namespace.createElement(\"span\", {\n      \"aria-owns\": portalNode.id,\n      style: HIDDEN_STYLES\n    }), portalNode && /*#__PURE__*/reactDom$1.createPortal(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/React__namespace.createElement(FocusGuard, {\n      \"data-type\": \"outside\",\n      ref: afterOutsideRef,\n      onFocus: event => {\n        if (isOutsideEvent(event, portalNode)) {\n          var _afterInsideRef$curre;\n          (_afterInsideRef$curre = afterInsideRef.current) == null ? void 0 : _afterInsideRef$curre.focus();\n        } else {\n          const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n          nextTabbable == null ? void 0 : nextTabbable.focus();\n          (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent));\n        }\n      }\n    }));\n  }\n  const usePortalContext = () => React__namespace.useContext(PortalContext);\n  const VisuallyHiddenDismiss = /*#__PURE__*/React__namespace.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n    return /*#__PURE__*/React__namespace.createElement(\"button\", _extends({}, props, {\n      type: \"button\",\n      ref: ref,\n      tabIndex: -1,\n      style: HIDDEN_STYLES\n    }));\n  });\n  /**\n   * Provides focus management for the floating element.\n   * @see https://floating-ui.com/docs/FloatingFocusManager\n   */\n  function FloatingFocusManager(props) {\n    const {\n      context,\n      children,\n      disabled = false,\n      order = ['content'],\n      guards: _guards = true,\n      initialFocus = 0,\n      returnFocus = true,\n      modal = true,\n      visuallyHiddenDismiss = false,\n      closeOnFocusOut = true\n    } = props;\n    const {\n      open,\n      refs,\n      nodeId,\n      onOpenChange,\n      events,\n      dataRef,\n      elements: {\n        domReference,\n        floating\n      }\n    } = context;\n\n    // Force the guards to be rendered if the `inert` attribute is not supported.\n    const guards = supportsInert() ? _guards : true;\n    const orderRef = useLatestRef(order);\n    const initialFocusRef = useLatestRef(initialFocus);\n    const returnFocusRef = useLatestRef(returnFocus);\n    const tree = useFloatingTree();\n    const portalContext = usePortalContext();\n\n    // Controlled by `useListNavigation`.\n    const ignoreInitialFocus = typeof initialFocus === 'number' && initialFocus < 0;\n    const startDismissButtonRef = React__namespace.useRef(null);\n    const endDismissButtonRef = React__namespace.useRef(null);\n    const preventReturnFocusRef = React__namespace.useRef(false);\n    const previouslyFocusedElementRef = React__namespace.useRef(null);\n    const isPointerDownRef = React__namespace.useRef(false);\n    const isInsidePortal = portalContext != null;\n\n    // If the reference is a combobox and is typeable (e.g. input/textarea),\n    // there are different focus semantics. The guards should not be rendered, but\n    // aria-hidden should be applied to all nodes still. Further, the visually\n    // hidden dismiss button should only appear at the end of the list, not the\n    // start.\n    const isTypeableCombobox = domReference && domReference.getAttribute('role') === 'combobox' && isTypeableElement(domReference);\n    const getTabbableContent = React__namespace.useCallback(function (container) {\n      if (container === void 0) {\n        container = floating;\n      }\n      return container ? tabbable(container, getTabbableOptions()) : [];\n    }, [floating]);\n    const getTabbableElements = React__namespace.useCallback(container => {\n      const content = getTabbableContent(container);\n      return orderRef.current.map(type => {\n        if (domReference && type === 'reference') {\n          return domReference;\n        }\n        if (floating && type === 'floating') {\n          return floating;\n        }\n        return content;\n      }).filter(Boolean).flat();\n    }, [domReference, floating, orderRef, getTabbableContent]);\n    React__namespace.useEffect(() => {\n      if (disabled || !modal) return;\n      function onKeyDown(event) {\n        if (event.key === 'Tab') {\n          // The focus guards have nothing to focus, so we need to stop the event.\n          if (contains(floating, activeElement(getDocument(floating))) && getTabbableContent().length === 0 && !isTypeableCombobox) {\n            stopEvent(event);\n          }\n          const els = getTabbableElements();\n          const target = getTarget(event);\n          if (orderRef.current[0] === 'reference' && target === domReference) {\n            stopEvent(event);\n            if (event.shiftKey) {\n              enqueueFocus(els[els.length - 1]);\n            } else {\n              enqueueFocus(els[1]);\n            }\n          }\n          if (orderRef.current[1] === 'floating' && target === floating && event.shiftKey) {\n            stopEvent(event);\n            enqueueFocus(els[0]);\n          }\n        }\n      }\n      const doc = getDocument(floating);\n      doc.addEventListener('keydown', onKeyDown);\n      return () => {\n        doc.removeEventListener('keydown', onKeyDown);\n      };\n    }, [disabled, domReference, floating, modal, orderRef, refs, isTypeableCombobox, getTabbableContent, getTabbableElements]);\n    React__namespace.useEffect(() => {\n      if (disabled || !closeOnFocusOut) return;\n\n      // In Safari, buttons lose focus when pressing them.\n      function handlePointerDown() {\n        isPointerDownRef.current = true;\n        setTimeout(() => {\n          isPointerDownRef.current = false;\n        });\n      }\n      function handleFocusOutside(event) {\n        const relatedTarget = event.relatedTarget;\n        queueMicrotask(() => {\n          const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute('focus-guard')) || tree && (getChildren(tree.nodesRef.current, nodeId).find(node => {\n            var _node$context, _node$context2;\n            return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n          }) || getAncestors(tree.nodesRef.current, nodeId).find(node => {\n            var _node$context3, _node$context4;\n            return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n          })));\n\n          // Focus did not move inside the floating tree, and there are no tabbable\n          // portal guards to handle closing.\n          if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current &&\n          // Fix React 18 Strict Mode returnFocus due to double rendering.\n          relatedTarget !== previouslyFocusedElementRef.current) {\n            preventReturnFocusRef.current = true;\n            onOpenChange(false, event);\n          }\n        });\n      }\n      if (floating && isHTMLElement(domReference)) {\n        domReference.addEventListener('focusout', handleFocusOutside);\n        domReference.addEventListener('pointerdown', handlePointerDown);\n        !modal && floating.addEventListener('focusout', handleFocusOutside);\n        return () => {\n          domReference.removeEventListener('focusout', handleFocusOutside);\n          domReference.removeEventListener('pointerdown', handlePointerDown);\n          !modal && floating.removeEventListener('focusout', handleFocusOutside);\n        };\n      }\n    }, [disabled, domReference, floating, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut]);\n    React__namespace.useEffect(() => {\n      var _portalContext$portal;\n      if (disabled) return;\n\n      // Don't hide portals nested within the parent portal.\n      const portalNodes = Array.from((portalContext == null ? void 0 : (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[\" + createAttribute('portal') + \"]\")) || []);\n      if (floating && modal) {\n        const insideNodes = [floating, ...portalNodes, startDismissButtonRef.current, endDismissButtonRef.current].filter(x => x != null);\n        const suppressorFn = guards ? hideOthers : suppressOthers;\n        const cleanup = suppressorFn(orderRef.current.includes('reference') || isTypeableCombobox ? insideNodes.concat(domReference || []) : insideNodes, undefined, createAttribute('inert'));\n        return () => {\n          cleanup();\n        };\n      }\n    }, [disabled, domReference, floating, modal, orderRef, portalContext, isTypeableCombobox, guards]);\n    index(() => {\n      if (disabled || !floating) return;\n      const doc = getDocument(floating);\n      const previouslyFocusedElement = activeElement(doc);\n\n      // Wait for any layout effect state setters to execute to set `tabIndex`.\n      queueMicrotask(() => {\n        const focusableElements = getTabbableElements(floating);\n        const initialFocusValue = initialFocusRef.current;\n        const elToFocus = (typeof initialFocusValue === 'number' ? focusableElements[initialFocusValue] : initialFocusValue.current) || floating;\n        const focusAlreadyInsideFloatingEl = contains(floating, previouslyFocusedElement);\n        if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n          enqueueFocus(elToFocus, {\n            preventScroll: elToFocus === floating\n          });\n        }\n      });\n    }, [disabled, open, floating, ignoreInitialFocus, getTabbableElements, initialFocusRef]);\n    index(() => {\n      if (disabled || !floating) return;\n      let preventReturnFocusScroll = false;\n      const doc = getDocument(floating);\n      const previouslyFocusedElement = activeElement(doc);\n      const contextData = dataRef.current;\n      previouslyFocusedElementRef.current = previouslyFocusedElement;\n\n      // Dismissing via outside press should always ignore `returnFocus` to\n      // prevent unwanted scrolling.\n      function onDismiss(payload) {\n        if (payload.type === 'escapeKey' && refs.domReference.current) {\n          previouslyFocusedElementRef.current = refs.domReference.current;\n        }\n        if (['referencePress', 'escapeKey'].includes(payload.type)) {\n          return;\n        }\n        const returnFocus = payload.data.returnFocus;\n        if (typeof returnFocus === 'object') {\n          preventReturnFocusRef.current = false;\n          preventReturnFocusScroll = returnFocus.preventScroll;\n        } else {\n          preventReturnFocusRef.current = !returnFocus;\n        }\n      }\n      events.on('dismiss', onDismiss);\n      return () => {\n        events.off('dismiss', onDismiss);\n        const activeEl = activeElement(doc);\n        const shouldFocusReference = contains(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n          var _node$context5;\n          return contains((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);\n        }) || contextData.openEvent && ['click', 'mousedown'].includes(contextData.openEvent.type);\n        if (shouldFocusReference && refs.domReference.current) {\n          previouslyFocusedElementRef.current = refs.domReference.current;\n        }\n        if (\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        returnFocusRef.current && isHTMLElement(previouslyFocusedElementRef.current) && !preventReturnFocusRef.current) {\n          enqueueFocus(previouslyFocusedElementRef.current, {\n            // When dismissing nested floating elements, by the time the rAF has\n            // executed, the menus will all have been unmounted. When they try\n            // to get focused, the calls get ignored — leaving the root\n            // reference focused as desired.\n            cancelPrevious: false,\n            preventScroll: preventReturnFocusScroll\n          });\n        }\n      };\n    }, [disabled, floating, returnFocusRef, dataRef, refs, events, tree, nodeId]);\n\n    // Synchronize the `context` & `modal` value to the FloatingPortal context.\n    // It will decide whether or not it needs to render its own guards.\n    index(() => {\n      if (disabled || !portalContext) return;\n      portalContext.setFocusManagerState({\n        ...context,\n        modal,\n        closeOnFocusOut,\n        open\n      });\n      return () => {\n        portalContext.setFocusManagerState(null);\n      };\n    }, [disabled, portalContext, modal, open, closeOnFocusOut, context]);\n    index(() => {\n      if (disabled) return;\n      if (floating && typeof MutationObserver === 'function') {\n        const handleMutation = () => {\n          const tabIndex = floating.getAttribute('tabindex');\n          if (orderRef.current.includes('floating') || activeElement(getDocument(floating)) !== refs.domReference.current && getTabbableContent().length === 0) {\n            if (tabIndex !== '0') {\n              floating.setAttribute('tabindex', '0');\n            }\n          } else if (tabIndex !== '-1') {\n            floating.setAttribute('tabindex', '-1');\n          }\n        };\n        handleMutation();\n        const observer = new MutationObserver(handleMutation);\n        observer.observe(floating, {\n          childList: true,\n          subtree: true,\n          attributes: true\n        });\n        return () => {\n          observer.disconnect();\n        };\n      }\n    }, [disabled, floating, refs, orderRef, getTabbableContent]);\n    function renderDismissButton(location) {\n      if (disabled || !visuallyHiddenDismiss || !modal) {\n        return null;\n      }\n      return /*#__PURE__*/React__namespace.createElement(VisuallyHiddenDismiss, {\n        ref: location === 'start' ? startDismissButtonRef : endDismissButtonRef,\n        onClick: event => onOpenChange(false, event.nativeEvent)\n      }, typeof visuallyHiddenDismiss === 'string' ? visuallyHiddenDismiss : 'Dismiss');\n    }\n    const shouldRenderGuards = !disabled && guards && !isTypeableCombobox && (isInsidePortal || modal);\n    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, shouldRenderGuards && /*#__PURE__*/React__namespace.createElement(FocusGuard, {\n      \"data-type\": \"inside\",\n      ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n      onFocus: event => {\n        if (modal) {\n          const els = getTabbableElements();\n          enqueueFocus(order[0] === 'reference' ? els[0] : els[els.length - 1]);\n        } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n          preventReturnFocusRef.current = false;\n          if (isOutsideEvent(event, portalContext.portalNode)) {\n            const nextTabbable = getNextTabbable() || domReference;\n            nextTabbable == null ? void 0 : nextTabbable.focus();\n          } else {\n            var _portalContext$before;\n            (_portalContext$before = portalContext.beforeOutsideRef.current) == null ? void 0 : _portalContext$before.focus();\n          }\n        }\n      }\n    }), !isTypeableCombobox && renderDismissButton('start'), children, renderDismissButton('end'), shouldRenderGuards && /*#__PURE__*/React__namespace.createElement(FocusGuard, {\n      \"data-type\": \"inside\",\n      ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n      onFocus: event => {\n        if (modal) {\n          enqueueFocus(getTabbableElements()[0]);\n        } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n          if (closeOnFocusOut) {\n            preventReturnFocusRef.current = true;\n          }\n          if (isOutsideEvent(event, portalContext.portalNode)) {\n            const prevTabbable = getPreviousTabbable() || domReference;\n            prevTabbable == null ? void 0 : prevTabbable.focus();\n          } else {\n            var _portalContext$afterO;\n            (_portalContext$afterO = portalContext.afterOutsideRef.current) == null ? void 0 : _portalContext$afterO.focus();\n          }\n        }\n      }\n    }));\n  }\n  function sortByDocumentPosition(a, b) {\n    const position = a.compareDocumentPosition(b);\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      return -1;\n    }\n    if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n      return 1;\n    }\n    return 0;\n  }\n  function areMapsEqual(map1, map2) {\n    if (map1.size !== map2.size) {\n      return false;\n    }\n    for (const [key, value] of map1.entries()) {\n      if (value !== map2.get(key)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const FloatingListContext = /*#__PURE__*/React__namespace.createContext({\n    register: () => {},\n    unregister: () => {},\n    map: /*#__PURE__*/new Map(),\n    elementsRef: {\n      current: []\n    }\n  });\n  /**\n   * Provides context for a list of items within the floating element.\n   * @see https://floating-ui.com/docs/FloatingList\n   */\n  function FloatingList(_ref) {\n    let {\n      children,\n      elementsRef,\n      labelsRef\n    } = _ref;\n    const [map, setMap] = React__namespace.useState(() => new Map());\n    const register = React__namespace.useCallback(node => {\n      setMap(prevMap => new Map(prevMap).set(node, null));\n    }, []);\n    const unregister = React__namespace.useCallback(node => {\n      setMap(prevMap => {\n        const map = new Map(prevMap);\n        map.delete(node);\n        return map;\n      });\n    }, []);\n    index(() => {\n      const newMap = new Map(map);\n      const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);\n      nodes.forEach((node, index) => {\n        newMap.set(node, index);\n      });\n      if (!areMapsEqual(map, newMap)) {\n        setMap(newMap);\n      }\n    }, [map]);\n    return /*#__PURE__*/React__namespace.createElement(FloatingListContext.Provider, {\n      value: React__namespace.useMemo(() => ({\n        register,\n        unregister,\n        map,\n        elementsRef,\n        labelsRef\n      }), [register, unregister, map, elementsRef, labelsRef])\n    }, children);\n  }\n  function useListItem(_temp) {\n    let {\n      label\n    } = _temp === void 0 ? {} : _temp;\n    const [index$1, setIndex] = React__namespace.useState(null);\n    const componentRef = React__namespace.useRef(null);\n    const {\n      register,\n      unregister,\n      map,\n      elementsRef,\n      labelsRef\n    } = React__namespace.useContext(FloatingListContext);\n    const ref = React__namespace.useCallback(node => {\n      componentRef.current = node;\n      if (index$1 !== null) {\n        elementsRef.current[index$1] = node;\n        if (labelsRef) {\n          var _node$textContent;\n          const isLabelDefined = label !== undefined;\n          labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n        }\n      }\n    }, [index$1, elementsRef, labelsRef, label]);\n    index(() => {\n      const node = componentRef.current;\n      if (node) {\n        register(node);\n        return () => {\n          unregister(node);\n        };\n      }\n    }, [register, unregister]);\n    index(() => {\n      const index = componentRef.current ? map.get(componentRef.current) : null;\n      if (index != null) {\n        setIndex(index);\n      }\n    }, [map]);\n    return React__namespace.useMemo(() => ({\n      ref,\n      index: index$1 == null ? -1 : index$1\n    }), [index$1, ref]);\n  }\n  const identifier = /*#__PURE__*/createAttribute('scroll-lock');\n\n  /**\n   * Provides base styling for a fixed overlay element to dim content or block\n   * pointer events behind a floating element.\n   * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n   * @see https://floating-ui.com/docs/FloatingOverlay\n   */\n  const FloatingOverlay = /*#__PURE__*/React__namespace.forwardRef(function FloatingOverlay(_ref, ref) {\n    let {\n      lockScroll = false,\n      ...rest\n    } = _ref;\n    index(() => {\n      var _window$visualViewpor, _window$visualViewpor2;\n      if (!lockScroll) {\n        return;\n      }\n      const alreadyLocked = document.body.hasAttribute(identifier);\n      if (alreadyLocked) {\n        return;\n      }\n      document.body.setAttribute(identifier, '');\n\n      // RTL <body> scrollbar\n      const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n      const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';\n      const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n\n      // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n      // technique has fewer side effects.\n      if (!/iP(hone|ad|od)|iOS/.test(getPlatform())) {\n        Object.assign(document.body.style, {\n          overflow: 'hidden',\n          [paddingProp]: scrollbarWidth + \"px\"\n        });\n        return () => {\n          document.body.removeAttribute(identifier);\n          Object.assign(document.body.style, {\n            overflow: '',\n            [paddingProp]: ''\n          });\n        };\n      }\n\n      // iOS 12 does not support `visualViewport`.\n      const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n      const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n      const scrollX = window.pageXOffset;\n      const scrollY = window.pageYOffset;\n      Object.assign(document.body.style, {\n        position: 'fixed',\n        overflow: 'hidden',\n        top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n        left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n        right: '0',\n        [paddingProp]: scrollbarWidth + \"px\"\n      });\n      return () => {\n        Object.assign(document.body.style, {\n          position: '',\n          overflow: '',\n          top: '',\n          left: '',\n          right: '',\n          [paddingProp]: ''\n        });\n        document.body.removeAttribute(identifier);\n        window.scrollTo(scrollX, scrollY);\n      };\n    }, [lockScroll]);\n    return /*#__PURE__*/React__namespace.createElement(\"div\", _extends({\n      ref: ref\n    }, rest, {\n      style: {\n        position: 'fixed',\n        overflow: 'auto',\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0,\n        ...rest.style\n      }\n    }));\n  });\n  function isButtonTarget(event) {\n    return isHTMLElement(event.target) && event.target.tagName === 'BUTTON';\n  }\n  function isSpaceIgnored(element) {\n    return isTypeableElement(element);\n  }\n  /**\n   * Opens or closes the floating element when clicking the reference element.\n   * @see https://floating-ui.com/docs/useClick\n   */\n  function useClick(context, props) {\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      open,\n      onOpenChange,\n      dataRef,\n      elements: {\n        domReference\n      }\n    } = context;\n    const {\n      enabled = true,\n      event: eventOption = 'click',\n      toggle = true,\n      ignoreMouse = false,\n      keyboardHandlers = true\n    } = props;\n    const pointerTypeRef = React__namespace.useRef();\n    const didKeyDownRef = React__namespace.useRef(false);\n    return React__namespace.useMemo(() => {\n      if (!enabled) return {};\n      return {\n        reference: {\n          onPointerDown(event) {\n            pointerTypeRef.current = event.pointerType;\n          },\n          onMouseDown(event) {\n            // Ignore all buttons except for the \"main\" button.\n            // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n            if (event.button !== 0) {\n              return;\n            }\n            if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n              return;\n            }\n            if (eventOption === 'click') {\n              return;\n            }\n            if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'mousedown' : true)) {\n              onOpenChange(false, event.nativeEvent);\n            } else {\n              // Prevent stealing focus from the floating element\n              event.preventDefault();\n              onOpenChange(true, event.nativeEvent);\n            }\n          },\n          onClick(event) {\n            if (eventOption === 'mousedown' && pointerTypeRef.current) {\n              pointerTypeRef.current = undefined;\n              return;\n            }\n            if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n              return;\n            }\n            if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'click' : true)) {\n              onOpenChange(false, event.nativeEvent);\n            } else {\n              onOpenChange(true, event.nativeEvent);\n            }\n          },\n          onKeyDown(event) {\n            pointerTypeRef.current = undefined;\n            if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n              return;\n            }\n            if (event.key === ' ' && !isSpaceIgnored(domReference)) {\n              // Prevent scrolling\n              event.preventDefault();\n              didKeyDownRef.current = true;\n            }\n            if (event.key === 'Enter') {\n              if (open && toggle) {\n                onOpenChange(false, event.nativeEvent);\n              } else {\n                onOpenChange(true, event.nativeEvent);\n              }\n            }\n          },\n          onKeyUp(event) {\n            if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n              return;\n            }\n            if (event.key === ' ' && didKeyDownRef.current) {\n              didKeyDownRef.current = false;\n              if (open && toggle) {\n                onOpenChange(false, event.nativeEvent);\n              } else {\n                onOpenChange(true, event.nativeEvent);\n              }\n            }\n          }\n        }\n      };\n    }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);\n  }\n\n  // `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`\n  const useInsertionEffect = React__namespace[/*#__PURE__*/'useInsertionEffect'.toString()];\n  const useSafeInsertionEffect = useInsertionEffect || (fn => fn());\n  function useEffectEvent(callback) {\n    const ref = React__namespace.useRef(() => {\n      if (process.env.NODE_ENV !== \"production\") {\n        throw new Error('Cannot call an event handler while rendering.');\n      }\n    });\n    useSafeInsertionEffect(() => {\n      ref.current = callback;\n    });\n    return React__namespace.useCallback(function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return ref.current == null ? void 0 : ref.current(...args);\n    }, []);\n  }\n  function createVirtualElement(domRef, data) {\n    let offsetX = null;\n    let offsetY = null;\n    let isAutoUpdateEvent = false;\n    return {\n      contextElement: domRef.current || undefined,\n      getBoundingClientRect() {\n        var _domRef$current, _data$dataRef$current;\n        const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {\n          width: 0,\n          height: 0,\n          x: 0,\n          y: 0\n        };\n        const isXAxis = data.axis === 'x' || data.axis === 'both';\n        const isYAxis = data.axis === 'y' || data.axis === 'both';\n        const canTrackCursorOnAutoUpdate = ['mouseenter', 'mousemove'].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || '') && data.pointerType !== 'touch';\n        let width = domRect.width;\n        let height = domRect.height;\n        let x = domRect.x;\n        let y = domRect.y;\n        if (offsetX == null && data.x && isXAxis) {\n          offsetX = domRect.x - data.x;\n        }\n        if (offsetY == null && data.y && isYAxis) {\n          offsetY = domRect.y - data.y;\n        }\n        x -= offsetX || 0;\n        y -= offsetY || 0;\n        width = 0;\n        height = 0;\n        if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n          width = data.axis === 'y' ? domRect.width : 0;\n          height = data.axis === 'x' ? domRect.height : 0;\n          x = isXAxis && data.x != null ? data.x : x;\n          y = isYAxis && data.y != null ? data.y : y;\n        } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n          height = data.axis === 'x' ? domRect.height : height;\n          width = data.axis === 'y' ? domRect.width : width;\n        }\n        isAutoUpdateEvent = true;\n        return {\n          width,\n          height,\n          x,\n          y,\n          top: y,\n          right: x + width,\n          bottom: y + height,\n          left: x\n        };\n      }\n    };\n  }\n  function isMouseBasedEvent(event) {\n    return event != null && event.clientX != null;\n  }\n  /**\n   * Positions the floating element relative to a client point (in the viewport),\n   * such as the mouse position. By default, it follows the mouse cursor.\n   * @see https://floating-ui.com/docs/useClientPoint\n   */\n  function useClientPoint(context, props) {\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      open,\n      refs,\n      dataRef,\n      elements: {\n        floating\n      }\n    } = context;\n    const {\n      enabled = true,\n      axis = 'both',\n      x = null,\n      y = null\n    } = props;\n    const initialRef = React__namespace.useRef(false);\n    const cleanupListenerRef = React__namespace.useRef(null);\n    const [pointerType, setPointerType] = React__namespace.useState();\n    const [reactive, setReactive] = React__namespace.useState([]);\n    const setReference = useEffectEvent((x, y) => {\n      if (initialRef.current) return;\n\n      // Prevent setting if the open event was not a mouse-like one\n      // (e.g. focus to open, then hover over the reference element).\n      // Only apply if the event exists.\n      if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n        return;\n      }\n      refs.setPositionReference(createVirtualElement(refs.domReference, {\n        x,\n        y,\n        axis,\n        dataRef,\n        pointerType\n      }));\n    });\n    const handleReferenceEnterOrMove = useEffectEvent(event => {\n      if (x != null || y != null) return;\n      if (!open) {\n        setReference(event.clientX, event.clientY);\n      } else if (!cleanupListenerRef.current) {\n        // If there's no cleanup, there's no listener, but we want to ensure\n        // we add the listener if the cursor landed on the floating element and\n        // then back on the reference (i.e. it's interactive).\n        setReactive([]);\n      }\n    });\n\n    // If the pointer is a mouse-like pointer, we want to continue following the\n    // mouse even if the floating element is transitioning out. On touch\n    // devices, this is undesirable because the floating element will move to\n    // the dismissal touch point.\n    const openCheck = isMouseLikePointerType(pointerType) ? floating : open;\n    const addListener = React__namespace.useCallback(() => {\n      // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n      if (!openCheck || !enabled || x != null || y != null) return;\n      const win = getWindow(refs.floating.current);\n      function handleMouseMove(event) {\n        const target = getTarget(event);\n        if (!contains(refs.floating.current, target)) {\n          setReference(event.clientX, event.clientY);\n        } else {\n          win.removeEventListener('mousemove', handleMouseMove);\n          cleanupListenerRef.current = null;\n        }\n      }\n      if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n        win.addEventListener('mousemove', handleMouseMove);\n        const cleanup = () => {\n          win.removeEventListener('mousemove', handleMouseMove);\n          cleanupListenerRef.current = null;\n        };\n        cleanupListenerRef.current = cleanup;\n        return cleanup;\n      }\n      refs.setPositionReference(refs.domReference.current);\n    }, [dataRef, enabled, openCheck, refs, setReference, x, y]);\n    React__namespace.useEffect(() => {\n      return addListener();\n    }, [addListener, reactive]);\n    React__namespace.useEffect(() => {\n      if (enabled && !floating) {\n        initialRef.current = false;\n      }\n    }, [enabled, floating]);\n    React__namespace.useEffect(() => {\n      if (!enabled && open) {\n        initialRef.current = true;\n      }\n    }, [enabled, open]);\n    index(() => {\n      if (enabled && (x != null || y != null)) {\n        initialRef.current = false;\n        setReference(x, y);\n      }\n    }, [enabled, x, y, setReference]);\n    return React__namespace.useMemo(() => {\n      if (!enabled) return {};\n      function setPointerTypeRef(_ref) {\n        let {\n          pointerType\n        } = _ref;\n        setPointerType(pointerType);\n      }\n      return {\n        reference: {\n          onPointerDown: setPointerTypeRef,\n          onPointerEnter: setPointerTypeRef,\n          onMouseMove: handleReferenceEnterOrMove,\n          onMouseEnter: handleReferenceEnterOrMove\n        }\n      };\n    }, [enabled, handleReferenceEnterOrMove]);\n  }\n\n  /**\n   * Check whether the event.target is within the provided node. Uses event.composedPath if available for custom element support.\n   *\n   * @param event The event whose target/composedPath to check\n   * @param node The node to check against\n   * @returns Whether the event.target/composedPath is within the node.\n   */\n  function isEventTargetWithin(event, node) {\n    if (node == null) {\n      return false;\n    }\n    if ('composedPath' in event) {\n      return event.composedPath().includes(node);\n    }\n\n    // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n    const e = event;\n    return e.target != null && node.contains(e.target);\n  }\n  const bubbleHandlerKeys = {\n    pointerdown: 'onPointerDown',\n    mousedown: 'onMouseDown',\n    click: 'onClick'\n  };\n  const captureHandlerKeys = {\n    pointerdown: 'onPointerDownCapture',\n    mousedown: 'onMouseDownCapture',\n    click: 'onClickCapture'\n  };\n  const normalizeBubblesProp = bubbles => {\n    var _bubbles$escapeKey, _bubbles$outsidePress;\n    return {\n      escapeKeyBubbles: typeof bubbles === 'boolean' ? bubbles : (_bubbles$escapeKey = bubbles == null ? void 0 : bubbles.escapeKey) != null ? _bubbles$escapeKey : false,\n      outsidePressBubbles: typeof bubbles === 'boolean' ? bubbles : (_bubbles$outsidePress = bubbles == null ? void 0 : bubbles.outsidePress) != null ? _bubbles$outsidePress : true\n    };\n  };\n  /**\n   * Closes the floating element when a dismissal is requested — by default, when\n   * the user presses the `escape` key or outside of the floating element.\n   * @see https://floating-ui.com/docs/useDismiss\n   */\n  function useDismiss(context, props) {\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      open,\n      onOpenChange,\n      events,\n      nodeId,\n      elements: {\n        reference,\n        domReference,\n        floating\n      },\n      dataRef\n    } = context;\n    const {\n      enabled = true,\n      escapeKey = true,\n      outsidePress: unstable_outsidePress = true,\n      outsidePressEvent = 'pointerdown',\n      referencePress = false,\n      referencePressEvent = 'pointerdown',\n      ancestorScroll = false,\n      bubbles\n    } = props;\n    const tree = useFloatingTree();\n    const nested = useFloatingParentNodeId() != null;\n    const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === 'function' ? unstable_outsidePress : () => false);\n    const outsidePress = typeof unstable_outsidePress === 'function' ? outsidePressFn : unstable_outsidePress;\n    const insideReactTreeRef = React__namespace.useRef(false);\n    const {\n      escapeKeyBubbles,\n      outsidePressBubbles\n    } = normalizeBubblesProp(bubbles);\n    const closeOnEscapeKeyDown = useEffectEvent(event => {\n      if (!open || !enabled || !escapeKey || event.key !== 'Escape') {\n        return;\n      }\n      const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n      if (!escapeKeyBubbles) {\n        event.stopPropagation();\n        if (children.length > 0) {\n          let shouldDismiss = true;\n          children.forEach(child => {\n            var _child$context;\n            if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n              shouldDismiss = false;\n              return;\n            }\n          });\n          if (!shouldDismiss) {\n            return;\n          }\n        }\n      }\n      events.emit('dismiss', {\n        type: 'escapeKey',\n        data: {\n          returnFocus: {\n            preventScroll: false\n          }\n        }\n      });\n      onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event);\n    });\n    const closeOnPressOutside = useEffectEvent(event => {\n      // Given developers can stop the propagation of the synthetic event,\n      // we can only be confident with a positive value.\n      const insideReactTree = insideReactTreeRef.current;\n      insideReactTreeRef.current = false;\n      if (insideReactTree) {\n        return;\n      }\n      if (typeof outsidePress === 'function' && !outsidePress(event)) {\n        return;\n      }\n      const target = getTarget(event);\n\n      // Check if the click occurred on the scrollbar\n      if (isHTMLElement(target) && floating) {\n        // In Firefox, `target.scrollWidth > target.clientWidth` for inline\n        // elements.\n        const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n        const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n        let xCond = canScrollY && event.offsetX > target.clientWidth;\n\n        // In some browsers it is possible to change the <body> (or window)\n        // scrollbar to the left side, but is very rare and is difficult to\n        // check for. Plus, for modal dialogs with backdrops, it is more\n        // important that the backdrop is checked but not so much the window.\n        if (canScrollY) {\n          const isRTL = getWindow(floating).getComputedStyle(target).direction === 'rtl';\n          if (isRTL) {\n            xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n          }\n        }\n        if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n          return;\n        }\n      }\n      const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n        var _node$context;\n        return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n      });\n      if (isEventTargetWithin(event, floating) || isEventTargetWithin(event, domReference) || targetIsInsideChildren) {\n        return;\n      }\n      const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n      if (children.length > 0) {\n        let shouldDismiss = true;\n        children.forEach(child => {\n          var _child$context2;\n          if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n            shouldDismiss = false;\n            return;\n          }\n        });\n        if (!shouldDismiss) {\n          return;\n        }\n      }\n      events.emit('dismiss', {\n        type: 'outsidePress',\n        data: {\n          returnFocus: nested ? {\n            preventScroll: true\n          } : isVirtualClick(event) || isVirtualPointerEvent(event)\n        }\n      });\n      onOpenChange(false, event);\n    });\n    React__namespace.useEffect(() => {\n      if (!open || !enabled) {\n        return;\n      }\n      dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n      dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n      function onScroll(event) {\n        onOpenChange(false, event);\n      }\n      const doc = getDocument(floating);\n      escapeKey && doc.addEventListener('keydown', closeOnEscapeKeyDown);\n      outsidePress && doc.addEventListener(outsidePressEvent, closeOnPressOutside);\n      let ancestors = [];\n      if (ancestorScroll) {\n        if (isElement(domReference)) {\n          ancestors = reactDom.getOverflowAncestors(domReference);\n        }\n        if (isElement(floating)) {\n          ancestors = ancestors.concat(reactDom.getOverflowAncestors(floating));\n        }\n        if (!isElement(reference) && reference && reference.contextElement) {\n          ancestors = ancestors.concat(reactDom.getOverflowAncestors(reference.contextElement));\n        }\n      }\n\n      // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n      ancestors = ancestors.filter(ancestor => {\n        var _doc$defaultView;\n        return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n      });\n      ancestors.forEach(ancestor => {\n        ancestor.addEventListener('scroll', onScroll, {\n          passive: true\n        });\n      });\n      return () => {\n        escapeKey && doc.removeEventListener('keydown', closeOnEscapeKeyDown);\n        outsidePress && doc.removeEventListener(outsidePressEvent, closeOnPressOutside);\n        ancestors.forEach(ancestor => {\n          ancestor.removeEventListener('scroll', onScroll);\n        });\n      };\n    }, [dataRef, floating, domReference, reference, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, closeOnPressOutside]);\n    React__namespace.useEffect(() => {\n      insideReactTreeRef.current = false;\n    }, [outsidePress, outsidePressEvent]);\n    return React__namespace.useMemo(() => {\n      if (!enabled) {\n        return {};\n      }\n      return {\n        reference: {\n          onKeyDown: closeOnEscapeKeyDown,\n          [bubbleHandlerKeys[referencePressEvent]]: event => {\n            if (referencePress) {\n              events.emit('dismiss', {\n                type: 'referencePress',\n                data: {\n                  returnFocus: false\n                }\n              });\n              onOpenChange(false, event.nativeEvent);\n            }\n          }\n        },\n        floating: {\n          onKeyDown: closeOnEscapeKeyDown,\n          [captureHandlerKeys[outsidePressEvent]]: () => {\n            insideReactTreeRef.current = true;\n          }\n        }\n      };\n    }, [enabled, events, referencePress, outsidePressEvent, referencePressEvent, onOpenChange, closeOnEscapeKeyDown]);\n  }\n\n  /**\n   * Provides data to position a floating element and context to add interactions.\n   * @see https://floating-ui.com/docs/react\n   */\n  function useFloating(options) {\n    var _options$elements;\n    if (options === void 0) {\n      options = {};\n    }\n    const {\n      open = false,\n      onOpenChange: unstable_onOpenChange,\n      nodeId\n    } = options;\n    const [_domReference, setDomReference] = React__namespace.useState(null);\n    const domReference = ((_options$elements = options.elements) == null ? void 0 : _options$elements.reference) || _domReference;\n    const position = reactDom.useFloating(options);\n    const tree = useFloatingTree();\n    const onOpenChange = useEffectEvent((open, event) => {\n      if (open) {\n        dataRef.current.openEvent = event;\n      }\n      unstable_onOpenChange == null ? void 0 : unstable_onOpenChange(open, event);\n    });\n    const domReferenceRef = React__namespace.useRef(null);\n    const dataRef = React__namespace.useRef({});\n    const events = React__namespace.useState(() => createPubSub())[0];\n    const floatingId = useId();\n    const setPositionReference = React__namespace.useCallback(node => {\n      const positionReference = isElement(node) ? {\n        getBoundingClientRect: () => node.getBoundingClientRect(),\n        contextElement: node\n      } : node;\n      position.refs.setReference(positionReference);\n    }, [position.refs]);\n    const setReference = React__namespace.useCallback(node => {\n      if (isElement(node) || node === null) {\n        domReferenceRef.current = node;\n        setDomReference(node);\n      }\n\n      // Backwards-compatibility for passing a virtual element to `reference`\n      // after it has set the DOM reference.\n      if (isElement(position.refs.reference.current) || position.refs.reference.current === null ||\n      // Don't allow setting virtual elements using the old technique back to\n      // `null` to support `positionReference` + an unstable `reference`\n      // callback ref.\n      node !== null && !isElement(node)) {\n        position.refs.setReference(node);\n      }\n    }, [position.refs]);\n    const refs = React__namespace.useMemo(() => ({\n      ...position.refs,\n      setReference,\n      setPositionReference,\n      domReference: domReferenceRef\n    }), [position.refs, setReference, setPositionReference]);\n    const elements = React__namespace.useMemo(() => ({\n      ...position.elements,\n      domReference: domReference\n    }), [position.elements, domReference]);\n    const context = React__namespace.useMemo(() => ({\n      ...position,\n      refs,\n      elements,\n      dataRef,\n      nodeId,\n      floatingId,\n      events,\n      open,\n      onOpenChange\n    }), [position, nodeId, floatingId, events, open, onOpenChange, refs, elements]);\n    index(() => {\n      const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);\n      if (node) {\n        node.context = context;\n      }\n    });\n    return React__namespace.useMemo(() => ({\n      ...position,\n      context,\n      refs,\n      elements\n    }), [position, refs, elements, context]);\n  }\n\n  /**\n   * Opens the floating element while the reference element has focus, like CSS\n   * `:focus`.\n   * @see https://floating-ui.com/docs/useFocus\n   */\n  function useFocus(context, props) {\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      open,\n      onOpenChange,\n      dataRef,\n      events,\n      refs,\n      elements: {\n        floating,\n        domReference\n      }\n    } = context;\n    const {\n      enabled = true,\n      keyboardOnly = true\n    } = props;\n    const pointerTypeRef = React__namespace.useRef('');\n    const blockFocusRef = React__namespace.useRef(false);\n    const timeoutRef = React__namespace.useRef();\n    React__namespace.useEffect(() => {\n      if (!enabled) {\n        return;\n      }\n      const doc = getDocument(floating);\n      const win = doc.defaultView || window;\n\n      // If the reference was focused and the user left the tab/window, and the\n      // floating element was not open, the focus should be blocked when they\n      // return to the tab/window.\n      function onBlur() {\n        if (!open && isHTMLElement(domReference) && domReference === activeElement(getDocument(domReference))) {\n          blockFocusRef.current = true;\n        }\n      }\n      win.addEventListener('blur', onBlur);\n      return () => {\n        win.removeEventListener('blur', onBlur);\n      };\n    }, [floating, domReference, open, enabled]);\n    React__namespace.useEffect(() => {\n      if (!enabled) {\n        return;\n      }\n      function onDismiss(payload) {\n        if (payload.type === 'referencePress' || payload.type === 'escapeKey') {\n          blockFocusRef.current = true;\n        }\n      }\n      events.on('dismiss', onDismiss);\n      return () => {\n        events.off('dismiss', onDismiss);\n      };\n    }, [events, enabled]);\n    React__namespace.useEffect(() => {\n      return () => {\n        clearTimeout(timeoutRef.current);\n      };\n    }, []);\n    return React__namespace.useMemo(() => {\n      if (!enabled) {\n        return {};\n      }\n      return {\n        reference: {\n          onPointerDown(_ref) {\n            let {\n              pointerType\n            } = _ref;\n            pointerTypeRef.current = pointerType;\n            blockFocusRef.current = !!(pointerType && keyboardOnly);\n          },\n          onMouseLeave() {\n            blockFocusRef.current = false;\n          },\n          onFocus(event) {\n            var _dataRef$current$open;\n            if (blockFocusRef.current) {\n              return;\n            }\n\n            // Dismiss with click should ignore the subsequent `focus` trigger,\n            // but only if the click originated inside the reference element.\n            if (event.type === 'focus' && ((_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type) === 'mousedown' && isEventTargetWithin(dataRef.current.openEvent, domReference)) {\n              return;\n            }\n            onOpenChange(true, event.nativeEvent);\n          },\n          onBlur(event) {\n            blockFocusRef.current = false;\n            const relatedTarget = event.relatedTarget;\n\n            // Hit the non-modal focus management portal guard. Focus will be\n            // moved into the floating element immediately after.\n            const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute('focus-guard')) && relatedTarget.getAttribute('data-type') === 'outside';\n\n            // Wait for the window blur listener to fire.\n            timeoutRef.current = setTimeout(() => {\n              // When focusing the reference element (e.g. regular click), then\n              // clicking into the floating element, prevent it from hiding.\n              // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n              if (contains(refs.floating.current, relatedTarget) || contains(domReference, relatedTarget) || movedToFocusGuard) {\n                return;\n              }\n              onOpenChange(false, event.nativeEvent);\n            });\n          }\n        }\n      };\n    }, [enabled, keyboardOnly, domReference, refs, dataRef, onOpenChange]);\n  }\n  function mergeProps(userProps, propsList, elementKey) {\n    const map = new Map();\n    return {\n      ...(elementKey === 'floating' && {\n        tabIndex: -1\n      }),\n      ...userProps,\n      ...propsList.map(value => value ? value[elementKey] : null).concat(userProps).reduce((acc, props) => {\n        if (!props) {\n          return acc;\n        }\n        Object.entries(props).forEach(_ref => {\n          let [key, value] = _ref;\n          if (key.indexOf('on') === 0) {\n            if (!map.has(key)) {\n              map.set(key, []);\n            }\n            if (typeof value === 'function') {\n              var _map$get;\n              (_map$get = map.get(key)) == null ? void 0 : _map$get.push(value);\n              acc[key] = function () {\n                var _map$get2;\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n                }\n                return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map(fn => fn(...args)).find(val => val !== undefined);\n              };\n            }\n          } else {\n            acc[key] = value;\n          }\n        });\n        return acc;\n      }, {})\n    };\n  }\n\n  /**\n   * Merges an array of interaction hooks' props into prop getters, allowing\n   * event handler functions to be composed together without overwriting one\n   * another.\n   * @see https://floating-ui.com/docs/react#interaction-hooks\n   */\n  function useInteractions(propsList) {\n    if (propsList === void 0) {\n      propsList = [];\n    }\n    // The dependencies are a dynamic array, so we can't use the linter's\n    // suggestion to add it to the deps array.\n    const deps = propsList;\n    const getReferenceProps = React__namespace.useCallback(userProps => mergeProps(userProps, propsList, 'reference'),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    deps);\n    const getFloatingProps = React__namespace.useCallback(userProps => mergeProps(userProps, propsList, 'floating'),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    deps);\n    const getItemProps = React__namespace.useCallback(userProps => mergeProps(userProps, propsList, 'item'),\n    // Granularly check for `item` changes, because the `getItemProps` getter\n    // should be as referentially stable as possible since it may be passed as\n    // a prop to many components. All `item` key values must therefore be\n    // memoized.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    propsList.map(key => key == null ? void 0 : key.item));\n    return React__namespace.useMemo(() => ({\n      getReferenceProps,\n      getFloatingProps,\n      getItemProps\n    }), [getReferenceProps, getFloatingProps, getItemProps]);\n  }\n  let isPreventScrollSupported = false;\n  const ARROW_UP = 'ArrowUp';\n  const ARROW_DOWN = 'ArrowDown';\n  const ARROW_LEFT = 'ArrowLeft';\n  const ARROW_RIGHT = 'ArrowRight';\n  function isDifferentRow(index, cols, prevRow) {\n    return Math.floor(index / cols) !== prevRow;\n  }\n  function isIndexOutOfBounds(listRef, index) {\n    return index < 0 || index >= listRef.current.length;\n  }\n  function findNonDisabledIndex(listRef, _temp) {\n    let {\n      startingIndex = -1,\n      decrement = false,\n      disabledIndices,\n      amount = 1\n    } = _temp === void 0 ? {} : _temp;\n    const list = listRef.current;\n    let index = startingIndex;\n    do {\n      var _list$index, _list$index2;\n      index = index + (decrement ? -amount : amount);\n    } while (index >= 0 && index <= list.length - 1 && (disabledIndices ? disabledIndices.includes(index) : list[index] == null || ((_list$index = list[index]) == null ? void 0 : _list$index.hasAttribute('disabled')) || ((_list$index2 = list[index]) == null ? void 0 : _list$index2.getAttribute('aria-disabled')) === 'true'));\n    return index;\n  }\n  function doSwitch(orientation, vertical, horizontal) {\n    switch (orientation) {\n      case 'vertical':\n        return vertical;\n      case 'horizontal':\n        return horizontal;\n      default:\n        return vertical || horizontal;\n    }\n  }\n  function isMainOrientationKey(key, orientation) {\n    const vertical = key === ARROW_UP || key === ARROW_DOWN;\n    const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal);\n  }\n  function isMainOrientationToEndKey(key, orientation, rtl) {\n    const vertical = key === ARROW_DOWN;\n    const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key == ' ' || key === '';\n  }\n  function isCrossOrientationOpenKey(key, orientation, rtl) {\n    const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    const horizontal = key === ARROW_DOWN;\n    return doSwitch(orientation, vertical, horizontal);\n  }\n  function isCrossOrientationCloseKey(key, orientation, rtl) {\n    const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n    const horizontal = key === ARROW_UP;\n    return doSwitch(orientation, vertical, horizontal);\n  }\n  function getMinIndex(listRef, disabledIndices) {\n    return findNonDisabledIndex(listRef, {\n      disabledIndices\n    });\n  }\n  function getMaxIndex(listRef, disabledIndices) {\n    return findNonDisabledIndex(listRef, {\n      decrement: true,\n      startingIndex: listRef.current.length,\n      disabledIndices\n    });\n  }\n  /**\n   * Adds arrow key-based navigation of a list of items, either using real DOM\n   * focus or virtual focus.\n   * @see https://floating-ui.com/docs/useListNavigation\n   */\n  function useListNavigation(context, props) {\n    const {\n      open,\n      onOpenChange,\n      refs,\n      elements: {\n        domReference,\n        floating\n      }\n    } = context;\n    const {\n      listRef,\n      activeIndex,\n      onNavigate: unstable_onNavigate = () => {},\n      enabled = true,\n      selectedIndex = null,\n      allowEscape = false,\n      loop = false,\n      nested = false,\n      rtl = false,\n      virtual = false,\n      focusItemOnOpen = 'auto',\n      focusItemOnHover = true,\n      openOnArrowKeyDown = true,\n      disabledIndices = undefined,\n      orientation = 'vertical',\n      cols = 1,\n      scrollItemIntoView = true\n    } = props;\n    if (process.env.NODE_ENV !== \"production\") {\n      if (allowEscape) {\n        if (!loop) {\n          console.warn(['Floating UI: `useListNavigation` looping must be enabled to allow', 'escaping.'].join(' '));\n        }\n        if (!virtual) {\n          console.warn(['Floating UI: `useListNavigation` must be virtual to allow', 'escaping.'].join(' '));\n        }\n      }\n      if (orientation === 'vertical' && cols > 1) {\n        console.warn(['Floating UI: In grid list navigation mode (`cols` > 1), the', '`orientation` should be either \"horizontal\" or \"both\".'].join(' '));\n      }\n    }\n    const parentId = useFloatingParentNodeId();\n    const tree = useFloatingTree();\n    const onNavigate = useEffectEvent(unstable_onNavigate);\n    const focusItemOnOpenRef = React__namespace.useRef(focusItemOnOpen);\n    const indexRef = React__namespace.useRef(selectedIndex != null ? selectedIndex : -1);\n    const keyRef = React__namespace.useRef(null);\n    const isPointerModalityRef = React__namespace.useRef(true);\n    const previousOnNavigateRef = React__namespace.useRef(onNavigate);\n    const previousMountedRef = React__namespace.useRef(!!floating);\n    const forceSyncFocus = React__namespace.useRef(false);\n    const forceScrollIntoViewRef = React__namespace.useRef(false);\n    const disabledIndicesRef = useLatestRef(disabledIndices);\n    const latestOpenRef = useLatestRef(open);\n    const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n    const [activeId, setActiveId] = React__namespace.useState();\n    const focusItem = useEffectEvent(function (listRef, indexRef, forceScrollIntoView) {\n      if (forceScrollIntoView === void 0) {\n        forceScrollIntoView = false;\n      }\n      const item = listRef.current[indexRef.current];\n      if (!item) return;\n      if (virtual) {\n        setActiveId(item.id);\n      } else {\n        enqueueFocus(item, {\n          preventScroll: true,\n          // Mac Safari does not move the virtual cursor unless the focus call\n          // is sync. However, for the very first focus call, we need to wait\n          // for the position to be ready in order to prevent unwanted\n          // scrolling. This means the virtual cursor will not move to the first\n          // item when first opening the floating element, but will on\n          // subsequent calls. `preventScroll` is supported in modern Safari,\n          // so we can use that instead.\n          // iOS Safari must be async or the first item will not be focused.\n          sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false\n        });\n      }\n      requestAnimationFrame(() => {\n        const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n        const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n        if (shouldScrollIntoView) {\n          // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n          // by all browsers.\n          item.scrollIntoView == null ? void 0 : item.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {\n            block: 'nearest',\n            inline: 'nearest'\n          } : scrollIntoViewOptions);\n        }\n      });\n    });\n    index(() => {\n      document.createElement('div').focus({\n        get preventScroll() {\n          isPreventScrollSupported = true;\n          return false;\n        }\n      });\n    }, []);\n\n    // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n    // element. Also, reset `activeIndex` upon closing the floating element.\n    index(() => {\n      if (!enabled) {\n        return;\n      }\n      if (open && floating) {\n        if (focusItemOnOpenRef.current && selectedIndex != null) {\n          // Regardless of the pointer modality, we want to ensure the selected\n          // item comes into view when the floating element is opened.\n          forceScrollIntoViewRef.current = true;\n          onNavigate(selectedIndex);\n        }\n      } else if (previousMountedRef.current) {\n        // Since the user can specify `onNavigate` conditionally\n        // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n        // we store and call the previous function.\n        indexRef.current = -1;\n        previousOnNavigateRef.current(null);\n      }\n    }, [enabled, open, floating, selectedIndex, onNavigate]);\n\n    // Sync `activeIndex` to be the focused item while the floating element is\n    // open.\n    index(() => {\n      if (!enabled) {\n        return;\n      }\n      if (open && floating) {\n        if (activeIndex == null) {\n          forceSyncFocus.current = false;\n          if (selectedIndex != null) {\n            return;\n          }\n\n          // Reset while the floating element was open (e.g. the list changed).\n          if (previousMountedRef.current) {\n            indexRef.current = -1;\n            focusItem(listRef, indexRef);\n          }\n\n          // Initial sync.\n          if (!previousMountedRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n            let runs = 0;\n            const waitForListPopulated = () => {\n              if (listRef.current[0] == null) {\n                // Avoid letting the browser paint if possible on the first try,\n                // otherwise use rAF. Don't try more than twice, since something\n                // is wrong otherwise.\n                if (runs < 2) {\n                  const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                  scheduler(waitForListPopulated);\n                }\n                runs++;\n              } else {\n                indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n                keyRef.current = null;\n                onNavigate(indexRef.current);\n              }\n            };\n            waitForListPopulated();\n          }\n        } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n          indexRef.current = activeIndex;\n          focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n          forceScrollIntoViewRef.current = false;\n        }\n      }\n    }, [enabled, open, floating, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);\n\n    // Ensure the parent floating element has focus when a nested child closes\n    // to allow arrow key navigation to work after the pointer leaves the child.\n    index(() => {\n      if (!enabled) {\n        return;\n      }\n      if (previousMountedRef.current && !floating && tree) {\n        var _nodes$find, _nodes$find$context;\n        const nodes = tree.nodesRef.current;\n        const parent = (_nodes$find = nodes.find(node => node.id === parentId)) == null ? void 0 : (_nodes$find$context = _nodes$find.context) == null ? void 0 : _nodes$find$context.elements.floating;\n        const activeEl = activeElement(getDocument(floating));\n        const treeContainsActiveEl = nodes.some(node => node.context && contains(node.context.elements.floating, activeEl));\n        if (parent && !treeContainsActiveEl) {\n          parent.focus({\n            preventScroll: true\n          });\n        }\n      }\n    }, [enabled, floating, tree, parentId]);\n    index(() => {\n      previousOnNavigateRef.current = onNavigate;\n      previousMountedRef.current = !!floating;\n    });\n    index(() => {\n      if (!open) {\n        keyRef.current = null;\n      }\n    }, [open]);\n    const hasActiveIndex = activeIndex != null;\n    const item = React__namespace.useMemo(() => {\n      function syncCurrentTarget(currentTarget) {\n        if (!open) return;\n        const index = listRef.current.indexOf(currentTarget);\n        if (index !== -1) {\n          onNavigate(index);\n        }\n      }\n      const props = {\n        onFocus(_ref) {\n          let {\n            currentTarget\n          } = _ref;\n          syncCurrentTarget(currentTarget);\n        },\n        onClick: _ref2 => {\n          let {\n            currentTarget\n          } = _ref2;\n          return currentTarget.focus({\n            preventScroll: true\n          });\n        },\n        // Safari\n        ...(focusItemOnHover && {\n          onMouseMove(_ref3) {\n            let {\n              currentTarget\n            } = _ref3;\n            syncCurrentTarget(currentTarget);\n          },\n          onPointerLeave(_ref4) {\n            let {\n              pointerType\n            } = _ref4;\n            if (!isPointerModalityRef.current || pointerType === 'touch') {\n              return;\n            }\n            indexRef.current = -1;\n            focusItem(listRef, indexRef);\n            onNavigate(null);\n            if (!virtual) {\n              enqueueFocus(refs.floating.current, {\n                preventScroll: true\n              });\n            }\n          }\n        })\n      };\n      return props;\n    }, [open, refs, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);\n    return React__namespace.useMemo(() => {\n      if (!enabled) {\n        return {};\n      }\n      const disabledIndices = disabledIndicesRef.current;\n      function onKeyDown(event) {\n        isPointerModalityRef.current = false;\n        forceSyncFocus.current = true;\n\n        // If the floating element is animating out, ignore navigation. Otherwise,\n        // the `activeIndex` gets set to 0 despite not being open so the next time\n        // the user ArrowDowns, the first item won't be focused.\n        if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n          return;\n        }\n        if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n          stopEvent(event);\n          onOpenChange(false, event.nativeEvent);\n          if (isHTMLElement(domReference)) {\n            domReference.focus();\n          }\n          return;\n        }\n        const currentIndex = indexRef.current;\n        const minIndex = getMinIndex(listRef, disabledIndices);\n        const maxIndex = getMaxIndex(listRef, disabledIndices);\n        if (event.key === 'Home') {\n          stopEvent(event);\n          indexRef.current = minIndex;\n          onNavigate(indexRef.current);\n        }\n        if (event.key === 'End') {\n          stopEvent(event);\n          indexRef.current = maxIndex;\n          onNavigate(indexRef.current);\n        }\n\n        // Grid navigation.\n        if (cols > 1) {\n          const prevIndex = indexRef.current;\n          if (event.key === ARROW_UP) {\n            stopEvent(event);\n            if (prevIndex === -1) {\n              indexRef.current = maxIndex;\n            } else {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex,\n                amount: cols,\n                decrement: true,\n                disabledIndices\n              });\n              if (loop && (prevIndex - cols < minIndex || indexRef.current < 0)) {\n                const col = prevIndex % cols;\n                const maxCol = maxIndex % cols;\n                const offset = maxIndex - (maxCol - col);\n                if (maxCol === col) {\n                  indexRef.current = maxIndex;\n                } else {\n                  indexRef.current = maxCol > col ? offset : offset - cols;\n                }\n              }\n            }\n            if (isIndexOutOfBounds(listRef, indexRef.current)) {\n              indexRef.current = prevIndex;\n            }\n            onNavigate(indexRef.current);\n          }\n          if (event.key === ARROW_DOWN) {\n            stopEvent(event);\n            if (prevIndex === -1) {\n              indexRef.current = minIndex;\n            } else {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex,\n                amount: cols,\n                disabledIndices\n              });\n              if (loop && prevIndex + cols > maxIndex) {\n                indexRef.current = findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex % cols - cols,\n                  amount: cols,\n                  disabledIndices\n                });\n              }\n            }\n            if (isIndexOutOfBounds(listRef, indexRef.current)) {\n              indexRef.current = prevIndex;\n            }\n            onNavigate(indexRef.current);\n          }\n\n          // Remains on the same row/column.\n          if (orientation === 'both') {\n            const prevRow = Math.floor(prevIndex / cols);\n            if (event.key === ARROW_RIGHT) {\n              stopEvent(event);\n              if (prevIndex % cols !== cols - 1) {\n                indexRef.current = findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex,\n                  disabledIndices\n                });\n                if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                  indexRef.current = findNonDisabledIndex(listRef, {\n                    startingIndex: prevIndex - prevIndex % cols - 1,\n                    disabledIndices\n                  });\n                }\n              } else if (loop) {\n                indexRef.current = findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex - prevIndex % cols - 1,\n                  disabledIndices\n                });\n              }\n              if (isDifferentRow(indexRef.current, cols, prevRow)) {\n                indexRef.current = prevIndex;\n              }\n            }\n            if (event.key === ARROW_LEFT) {\n              stopEvent(event);\n              if (prevIndex % cols !== 0) {\n                indexRef.current = findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex,\n                  disabledIndices,\n                  decrement: true\n                });\n                if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                  indexRef.current = findNonDisabledIndex(listRef, {\n                    startingIndex: prevIndex + (cols - prevIndex % cols),\n                    decrement: true,\n                    disabledIndices\n                  });\n                }\n              } else if (loop) {\n                indexRef.current = findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex + (cols - prevIndex % cols),\n                  decrement: true,\n                  disabledIndices\n                });\n              }\n              if (isDifferentRow(indexRef.current, cols, prevRow)) {\n                indexRef.current = prevIndex;\n              }\n            }\n            const lastRow = Math.floor(maxIndex / cols) === prevRow;\n            if (isIndexOutOfBounds(listRef, indexRef.current)) {\n              if (loop && lastRow) {\n                indexRef.current = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex - prevIndex % cols - 1,\n                  disabledIndices\n                });\n              } else {\n                indexRef.current = prevIndex;\n              }\n            }\n            onNavigate(indexRef.current);\n            return;\n          }\n        }\n        if (isMainOrientationKey(event.key, orientation)) {\n          stopEvent(event);\n\n          // Reset the index if no item is focused.\n          if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {\n            indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n            onNavigate(indexRef.current);\n            return;\n          }\n          if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n            if (loop) {\n              indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n                startingIndex: currentIndex,\n                disabledIndices\n              });\n            } else {\n              indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n                startingIndex: currentIndex,\n                disabledIndices\n              }));\n            }\n          } else {\n            if (loop) {\n              indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n                startingIndex: currentIndex,\n                decrement: true,\n                disabledIndices\n              });\n            } else {\n              indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n                startingIndex: currentIndex,\n                decrement: true,\n                disabledIndices\n              }));\n            }\n          }\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            onNavigate(null);\n          } else {\n            onNavigate(indexRef.current);\n          }\n        }\n      }\n      function checkVirtualMouse(event) {\n        if (focusItemOnOpen === 'auto' && isVirtualClick(event.nativeEvent)) {\n          focusItemOnOpenRef.current = true;\n        }\n      }\n      function checkVirtualPointer(event) {\n        // `pointerdown` fires first, reset the state then perform the checks.\n        focusItemOnOpenRef.current = focusItemOnOpen;\n        if (focusItemOnOpen === 'auto' && isVirtualPointerEvent(event.nativeEvent)) {\n          focusItemOnOpenRef.current = true;\n        }\n      }\n      const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {\n        'aria-activedescendant': activeId\n      };\n      return {\n        reference: {\n          ...ariaActiveDescendantProp,\n          onKeyDown(event) {\n            isPointerModalityRef.current = false;\n            const isArrowKey = event.key.indexOf('Arrow') === 0;\n            if (virtual && open) {\n              return onKeyDown(event);\n            }\n\n            // If a floating element should not open on arrow key down, avoid\n            // setting `activeIndex` while it's closed.\n            if (!open && !openOnArrowKeyDown && isArrowKey) {\n              return;\n            }\n            const isNavigationKey = isArrowKey || event.key === 'Enter' || event.key.trim() === '';\n            const isMainKey = isMainOrientationKey(event.key, orientation);\n            const isCrossKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n            if (isNavigationKey) {\n              keyRef.current = nested && isMainKey ? null : event.key;\n            }\n            if (nested) {\n              if (isCrossKey) {\n                stopEvent(event);\n                if (open) {\n                  indexRef.current = getMinIndex(listRef, disabledIndices);\n                  onNavigate(indexRef.current);\n                } else {\n                  onOpenChange(true, event.nativeEvent);\n                }\n              }\n              return;\n            }\n            if (isMainKey) {\n              if (selectedIndex != null) {\n                indexRef.current = selectedIndex;\n              }\n              stopEvent(event);\n              if (!open && openOnArrowKeyDown) {\n                onOpenChange(true, event.nativeEvent);\n              } else {\n                onKeyDown(event);\n              }\n              if (open) {\n                onNavigate(indexRef.current);\n              }\n            }\n          },\n          onFocus() {\n            if (open) {\n              onNavigate(null);\n            }\n          },\n          onPointerDown: checkVirtualPointer,\n          onMouseDown: checkVirtualMouse,\n          onClick: checkVirtualMouse\n        },\n        floating: {\n          'aria-orientation': orientation === 'both' ? undefined : orientation,\n          ...ariaActiveDescendantProp,\n          onKeyDown,\n          onPointerMove() {\n            isPointerModalityRef.current = true;\n          }\n        },\n        item\n      };\n    }, [domReference, refs, activeId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item]);\n  }\n\n  /**\n   * Merges an array of refs into a single memoized callback ref or `null`.\n   * @see https://floating-ui.com/docs/useMergeRefs\n   */\n  function useMergeRefs(refs) {\n    return React__namespace.useMemo(() => {\n      if (refs.every(ref => ref == null)) {\n        return null;\n      }\n      return value => {\n        refs.forEach(ref => {\n          if (typeof ref === 'function') {\n            ref(value);\n          } else if (ref != null) {\n            ref.current = value;\n          }\n        });\n      };\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, refs);\n  }\n\n  /**\n   * Adds base screen reader props to the reference and floating elements for a\n   * given floating element `role`.\n   * @see https://floating-ui.com/docs/useRole\n   */\n  function useRole(context, props) {\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      open,\n      floatingId\n    } = context;\n    const {\n      enabled = true,\n      role = 'dialog'\n    } = props;\n    const referenceId = useId();\n    return React__namespace.useMemo(() => {\n      const floatingProps = {\n        id: floatingId,\n        role\n      };\n      if (!enabled) {\n        return {};\n      }\n      if (role === 'tooltip') {\n        return {\n          reference: {\n            'aria-describedby': open ? floatingId : undefined\n          },\n          floating: floatingProps\n        };\n      }\n      return {\n        reference: {\n          'aria-expanded': open ? 'true' : 'false',\n          'aria-haspopup': role === 'alertdialog' ? 'dialog' : role,\n          'aria-controls': open ? floatingId : undefined,\n          ...(role === 'listbox' && {\n            role: 'combobox'\n          }),\n          ...(role === 'menu' && {\n            id: referenceId\n          })\n        },\n        floating: {\n          ...floatingProps,\n          ...(role === 'menu' && {\n            'aria-labelledby': referenceId\n          })\n        }\n      };\n    }, [enabled, role, open, floatingId, referenceId]);\n  }\n\n  // Converts a JS style key like `backgroundColor` to a CSS transition-property\n  // like `background-color`.\n  const camelCaseToKebabCase = str => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());\n  function execWithArgsOrReturn(valueOrFn, args) {\n    return typeof valueOrFn === 'function' ? valueOrFn(args) : valueOrFn;\n  }\n  function useDelayUnmount(open, durationMs) {\n    const [isMounted, setIsMounted] = React__namespace.useState(open);\n    if (open && !isMounted) {\n      setIsMounted(true);\n    }\n    React__namespace.useEffect(() => {\n      if (!open) {\n        const timeout = setTimeout(() => setIsMounted(false), durationMs);\n        return () => clearTimeout(timeout);\n      }\n    }, [open, durationMs]);\n    return isMounted;\n  }\n  /**\n   * Provides a status string to apply CSS transitions to a floating element,\n   * correctly handling placement-aware transitions.\n   * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n   */\n  function useTransitionStatus(context, props) {\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      open,\n      elements: {\n        floating\n      }\n    } = context;\n    const {\n      duration = 250\n    } = props;\n    const isNumberDuration = typeof duration === 'number';\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    const [initiated, setInitiated] = React__namespace.useState(false);\n    const [status, setStatus] = React__namespace.useState('unmounted');\n    const isMounted = useDelayUnmount(open, closeDuration);\n\n    // `initiated` check prevents this `setState` call from breaking\n    // <FloatingPortal />. This call is necessary to ensure subsequent opens\n    // after the initial one allows the correct side animation to play when the\n    // placement has changed.\n    index(() => {\n      if (initiated && !isMounted) {\n        setStatus('unmounted');\n      }\n    }, [initiated, isMounted]);\n    index(() => {\n      if (!floating) return;\n      if (open) {\n        setStatus('initial');\n        const frame = requestAnimationFrame(() => {\n          setStatus('open');\n        });\n        return () => {\n          cancelAnimationFrame(frame);\n        };\n      } else {\n        setInitiated(true);\n        setStatus('close');\n      }\n    }, [open, floating]);\n    return {\n      isMounted,\n      status\n    };\n  }\n  /**\n   * Provides styles to apply CSS transitions to a floating element, correctly\n   * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n   * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n   */\n  function useTransitionStyles(context, props) {\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      initial: unstable_initial = {\n        opacity: 0\n      },\n      open: unstable_open,\n      close: unstable_close,\n      common: unstable_common,\n      duration = 250\n    } = props;\n    const placement = context.placement;\n    const side = placement.split('-')[0];\n    const fnArgs = React__namespace.useMemo(() => ({\n      side,\n      placement\n    }), [side, placement]);\n    const isNumberDuration = typeof duration === 'number';\n    const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    const [styles, setStyles] = React__namespace.useState(() => ({\n      ...execWithArgsOrReturn(unstable_common, fnArgs),\n      ...execWithArgsOrReturn(unstable_initial, fnArgs)\n    }));\n    const {\n      isMounted,\n      status\n    } = useTransitionStatus(context, {\n      duration\n    });\n    const initialRef = useLatestRef(unstable_initial);\n    const openRef = useLatestRef(unstable_open);\n    const closeRef = useLatestRef(unstable_close);\n    const commonRef = useLatestRef(unstable_common);\n    index(() => {\n      const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n      const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n      const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n      const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key) => {\n        acc[key] = '';\n        return acc;\n      }, {});\n      if (status === 'initial') {\n        setStyles(styles => ({\n          transitionProperty: styles.transitionProperty,\n          ...commonStyles,\n          ...initialStyles\n        }));\n      }\n      if (status === 'open') {\n        setStyles({\n          transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(','),\n          transitionDuration: openDuration + \"ms\",\n          ...commonStyles,\n          ...openStyles\n        });\n      }\n      if (status === 'close') {\n        const styles = closeStyles || initialStyles;\n        setStyles({\n          transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(','),\n          transitionDuration: closeDuration + \"ms\",\n          ...commonStyles,\n          ...styles\n        });\n      }\n    }, [closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status, fnArgs]);\n    return {\n      isMounted,\n      styles\n    };\n  }\n\n  /**\n   * Provides a matching callback that can be used to focus an item as the user\n   * types, often used in tandem with `useListNavigation()`.\n   * @see https://floating-ui.com/docs/useTypeahead\n   */\n  function useTypeahead(context, props) {\n    var _ref;\n    const {\n      open,\n      dataRef\n    } = context;\n    const {\n      listRef,\n      activeIndex,\n      onMatch: unstable_onMatch,\n      onTypingChange: unstable_onTypingChange,\n      enabled = true,\n      findMatch = null,\n      resetMs = 750,\n      ignoreKeys = [],\n      selectedIndex = null\n    } = props;\n    const timeoutIdRef = React__namespace.useRef();\n    const stringRef = React__namespace.useRef('');\n    const prevIndexRef = React__namespace.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n    const matchIndexRef = React__namespace.useRef(null);\n    const onMatch = useEffectEvent(unstable_onMatch);\n    const onTypingChange = useEffectEvent(unstable_onTypingChange);\n    const findMatchRef = useLatestRef(findMatch);\n    const ignoreKeysRef = useLatestRef(ignoreKeys);\n    index(() => {\n      if (open) {\n        clearTimeout(timeoutIdRef.current);\n        matchIndexRef.current = null;\n        stringRef.current = '';\n      }\n    }, [open]);\n    index(() => {\n      // Sync arrow key navigation but not typeahead navigation.\n      if (open && stringRef.current === '') {\n        var _ref2;\n        prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n      }\n    }, [open, selectedIndex, activeIndex]);\n    return React__namespace.useMemo(() => {\n      if (!enabled) {\n        return {};\n      }\n      function setTypingChange(value) {\n        if (value) {\n          if (!dataRef.current.typing) {\n            dataRef.current.typing = value;\n            onTypingChange(value);\n          }\n        } else {\n          if (dataRef.current.typing) {\n            dataRef.current.typing = value;\n            onTypingChange(value);\n          }\n        }\n      }\n      function getMatchingIndex(list, orderedList, string) {\n        const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n        return str ? list.indexOf(str) : -1;\n      }\n      function onKeyDown(event) {\n        const listContent = listRef.current;\n        if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {\n          if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n            setTypingChange(false);\n          } else if (event.key === ' ') {\n            stopEvent(event);\n          }\n        }\n        if (listContent == null || ignoreKeysRef.current.includes(event.key) ||\n        // Character key.\n        event.key.length !== 1 ||\n        // Modifier key.\n        event.ctrlKey || event.metaKey || event.altKey) {\n          return;\n        }\n        if (open && event.key !== ' ') {\n          stopEvent(event);\n          setTypingChange(true);\n        }\n\n        // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n        // allow it in this case, too.\n        const allowRapidSuccessionOfFirstLetter = listContent.every(text => {\n          var _text$, _text$2;\n          return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n        });\n\n        // Allows the user to cycle through items that start with the same letter\n        // in rapid succession.\n        if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n          stringRef.current = '';\n          prevIndexRef.current = matchIndexRef.current;\n        }\n        stringRef.current += event.key;\n        clearTimeout(timeoutIdRef.current);\n        timeoutIdRef.current = setTimeout(() => {\n          stringRef.current = '';\n          prevIndexRef.current = matchIndexRef.current;\n          setTypingChange(false);\n        }, resetMs);\n        const prevIndex = prevIndexRef.current;\n        const index = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);\n        if (index !== -1) {\n          onMatch(index);\n          matchIndexRef.current = index;\n        } else if (event.key !== ' ') {\n          stringRef.current = '';\n          setTypingChange(false);\n        }\n      }\n      return {\n        reference: {\n          onKeyDown\n        },\n        floating: {\n          onKeyDown,\n          onKeyUp(event) {\n            if (event.key === ' ') {\n              setTypingChange(false);\n            }\n          }\n        }\n      };\n    }, [enabled, open, dataRef, listRef, resetMs, ignoreKeysRef, findMatchRef, onMatch, onTypingChange]);\n  }\n  function getArgsWithCustomFloatingHeight(state, height) {\n    return {\n      ...state,\n      rects: {\n        ...state.rects,\n        floating: {\n          ...state.rects.floating,\n          height\n        }\n      }\n    };\n  }\n  /**\n   * Positions the floating element such that an inner element inside\n   * of it is anchored to the reference element.\n   * @see https://floating-ui.com/docs/inner\n   */\n  const inner = props => ({\n    name: 'inner',\n    options: props,\n    async fn(state) {\n      const {\n        listRef,\n        overflowRef,\n        onFallbackChange,\n        offset: innerOffset = 0,\n        index = 0,\n        minItemsVisible = 4,\n        referenceOverflowThreshold = 0,\n        scrollRef,\n        ...detectOverflowOptions\n      } = props;\n      const {\n        rects,\n        elements: {\n          floating\n        }\n      } = state;\n      const item = listRef.current[index];\n      if (process.env.NODE_ENV !== \"production\") {\n        if (!state.placement.startsWith('bottom')) {\n          console.warn(['Floating UI: `placement` side must be \"bottom\" when using the', '`inner` middleware.'].join(' '));\n        }\n      }\n      if (!item) {\n        return {};\n      }\n      const nextArgs = {\n        ...state,\n        ...(await reactDom.offset(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state))\n      };\n      const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n      const overflow = await reactDom.detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n      const refOverflow = await reactDom.detectOverflow(nextArgs, {\n        ...detectOverflowOptions,\n        elementContext: 'reference'\n      });\n      const diffY = Math.max(0, overflow.top);\n      const nextY = nextArgs.y + diffY;\n      const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n      el.style.maxHeight = maxHeight + \"px\";\n      el.scrollTop = diffY;\n\n      // There is not enough space, fallback to standard anchored positioning\n      if (onFallbackChange) {\n        if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n          reactDom$1.flushSync(() => onFallbackChange(true));\n        } else {\n          reactDom$1.flushSync(() => onFallbackChange(false));\n        }\n      }\n      if (overflowRef) {\n        overflowRef.current = await reactDom.detectOverflow(getArgsWithCustomFloatingHeight({\n          ...nextArgs,\n          y: nextY\n        }, el.offsetHeight), detectOverflowOptions);\n      }\n      return {\n        y: nextY\n      };\n    }\n  });\n  /**\n   * Changes the `inner` middleware's `offset` upon a `wheel` event to\n   * expand the floating element's height, revealing more list items.\n   * @see https://floating-ui.com/docs/inner\n   */\n  function useInnerOffset(context, props) {\n    const {\n      open,\n      elements\n    } = context;\n    const {\n      enabled = true,\n      overflowRef,\n      scrollRef,\n      onChange: unstable_onChange\n    } = props;\n    const onChange = useEffectEvent(unstable_onChange);\n    const controlledScrollingRef = React__namespace.useRef(false);\n    const prevScrollTopRef = React__namespace.useRef(null);\n    const initialOverflowRef = React__namespace.useRef(null);\n    React__namespace.useEffect(() => {\n      if (!enabled) {\n        return;\n      }\n      function onWheel(e) {\n        if (e.ctrlKey || !el || overflowRef.current == null) {\n          return;\n        }\n        const dY = e.deltaY;\n        const isAtTop = overflowRef.current.top >= -0.5;\n        const isAtBottom = overflowRef.current.bottom >= -0.5;\n        const remainingScroll = el.scrollHeight - el.clientHeight;\n        const sign = dY < 0 ? -1 : 1;\n        const method = dY < 0 ? 'max' : 'min';\n        if (el.scrollHeight <= el.clientHeight) {\n          return;\n        }\n        if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n          e.preventDefault();\n          reactDom$1.flushSync(() => {\n            onChange(d => d + Math[method](dY, remainingScroll * sign));\n          });\n        } else if (/firefox/i.test(getUserAgent())) {\n          // Needed to propagate scrolling during momentum scrolling phase once\n          // it gets limited by the boundary. UX improvement, not critical.\n          el.scrollTop += dY;\n        }\n      }\n      const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n      if (open && el) {\n        el.addEventListener('wheel', onWheel);\n\n        // Wait for the position to be ready.\n        requestAnimationFrame(() => {\n          prevScrollTopRef.current = el.scrollTop;\n          if (overflowRef.current != null) {\n            initialOverflowRef.current = {\n              ...overflowRef.current\n            };\n          }\n        });\n        return () => {\n          prevScrollTopRef.current = null;\n          initialOverflowRef.current = null;\n          el.removeEventListener('wheel', onWheel);\n        };\n      }\n    }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);\n    return React__namespace.useMemo(() => {\n      if (!enabled) {\n        return {};\n      }\n      return {\n        floating: {\n          onKeyDown() {\n            controlledScrollingRef.current = true;\n          },\n          onWheel() {\n            controlledScrollingRef.current = false;\n          },\n          onPointerMove() {\n            controlledScrollingRef.current = false;\n          },\n          onScroll() {\n            const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n            if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n              return;\n            }\n            if (prevScrollTopRef.current !== null) {\n              const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n              if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n                reactDom$1.flushSync(() => onChange(d => d + scrollDiff));\n              }\n            }\n\n            // [Firefox] Wait for the height change to have been applied.\n            requestAnimationFrame(() => {\n              prevScrollTopRef.current = el.scrollTop;\n            });\n          }\n        }\n      };\n    }, [enabled, overflowRef, elements.floating, scrollRef, onChange]);\n  }\n  function isPointInPolygon(point, polygon) {\n    const [x, y] = point;\n    let isInside = false;\n    const length = polygon.length;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const [xi, yi] = polygon[i] || [0, 0];\n      const [xj, yj] = polygon[j] || [0, 0];\n      const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n      if (intersect) {\n        isInside = !isInside;\n      }\n    }\n    return isInside;\n  }\n  function isInside(point, rect) {\n    return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n  }\n  /**\n   * Generates a safe polygon area that the user can traverse without closing the\n   * floating element once leaving the reference element.\n   * @see https://floating-ui.com/docs/useHover#safePolygon\n   */\n  function safePolygon(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const {\n      buffer = 0.5,\n      blockPointerEvents = false,\n      requireIntent = true\n    } = options;\n    let timeoutId;\n    let hasLanded = false;\n    let lastX = null;\n    let lastY = null;\n    let lastCursorTime = performance.now();\n    function getCursorSpeed(x, y) {\n      const currentTime = performance.now();\n      const elapsedTime = currentTime - lastCursorTime;\n      if (lastX === null || lastY === null || elapsedTime === 0) {\n        lastX = x;\n        lastY = y;\n        lastCursorTime = currentTime;\n        return null;\n      }\n      const deltaX = x - lastX;\n      const deltaY = y - lastY;\n      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n      const speed = distance / elapsedTime; // px / ms\n\n      lastX = x;\n      lastY = y;\n      lastCursorTime = currentTime;\n      return speed;\n    }\n    const fn = _ref => {\n      let {\n        x,\n        y,\n        placement,\n        elements,\n        onClose,\n        nodeId,\n        tree\n      } = _ref;\n      return function onMouseMove(event) {\n        function close() {\n          clearTimeout(timeoutId);\n          onClose();\n        }\n        clearTimeout(timeoutId);\n        if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n          return;\n        }\n        const {\n          clientX,\n          clientY\n        } = event;\n        const clientPoint = [clientX, clientY];\n        const target = getTarget(event);\n        const isLeave = event.type === 'mouseleave';\n        const isOverFloatingEl = contains(elements.floating, target);\n        const isOverReferenceEl = contains(elements.domReference, target);\n        const refRect = elements.domReference.getBoundingClientRect();\n        const rect = elements.floating.getBoundingClientRect();\n        const side = placement.split('-')[0];\n        const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n        const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n        const isOverReferenceRect = isInside(clientPoint, refRect);\n        const isFloatingWider = rect.width > refRect.width;\n        const isFloatingTaller = rect.height > refRect.height;\n        const left = (isFloatingWider ? refRect : rect).left;\n        const right = (isFloatingWider ? refRect : rect).right;\n        const top = (isFloatingTaller ? refRect : rect).top;\n        const bottom = (isFloatingTaller ? refRect : rect).bottom;\n        if (isOverFloatingEl) {\n          hasLanded = true;\n          if (!isLeave) {\n            return;\n          }\n        }\n        if (isOverReferenceEl) {\n          hasLanded = false;\n        }\n        if (isOverReferenceEl && !isLeave) {\n          hasLanded = true;\n          return;\n        }\n\n        // Prevent overlapping floating element from being stuck in an open-close\n        // loop: https://github.com/floating-ui/floating-ui/issues/1910\n        if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {\n          return;\n        }\n\n        // If any nested child is open, abort.\n        if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {\n          let {\n            context\n          } = _ref2;\n          return context == null ? void 0 : context.open;\n        })) {\n          return;\n        }\n\n        // If the pointer is leaving from the opposite side, the \"buffer\" logic\n        // creates a point where the floating element remains open, but should be\n        // ignored.\n        // A constant of 1 handles floating point rounding errors.\n        if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n          return close();\n        }\n\n        // Ignore when the cursor is within the rectangular trough between the\n        // two elements. Since the triangle is created from the cursor point,\n        // which can start beyond the ref element's edge, traversing back and\n        // forth from the ref to the floating element can cause it to close. This\n        // ensures it always remains open in that case.\n        let rectPoly = [];\n        switch (side) {\n          case 'top':\n            rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];\n            break;\n          case 'bottom':\n            rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];\n            break;\n          case 'left':\n            rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];\n            break;\n          case 'right':\n            rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];\n            break;\n        }\n        function getPolygon(_ref3) {\n          let [x, y] = _ref3;\n          switch (side) {\n            case 'top':\n              {\n                const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n                const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n                const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n                return [cursorPointOne, cursorPointTwo, ...commonPoints];\n              }\n            case 'bottom':\n              {\n                const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n                const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n                const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n                return [cursorPointOne, cursorPointTwo, ...commonPoints];\n              }\n            case 'left':\n              {\n                const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n                const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n                const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n                return [...commonPoints, cursorPointOne, cursorPointTwo];\n              }\n            case 'right':\n              {\n                const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n                const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n                const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n                return [cursorPointOne, cursorPointTwo, ...commonPoints];\n              }\n          }\n        }\n        if (isPointInPolygon([clientX, clientY], rectPoly)) {\n          return;\n        } else if (hasLanded && !isOverReferenceRect) {\n          return close();\n        }\n        if (!isLeave && requireIntent) {\n          const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n          const cursorSpeedThreshold = 0.1;\n          if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n            return close();\n          }\n        }\n        if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {\n          close();\n        } else if (!hasLanded && requireIntent) {\n          timeoutId = window.setTimeout(close, 40);\n        }\n      };\n    };\n    fn.__options = {\n      blockPointerEvents\n    };\n    return fn;\n  }\n  Object.defineProperty(exports, 'arrow', {\n    enumerable: true,\n    get: function () {\n      return reactDom.arrow;\n    }\n  });\n  Object.defineProperty(exports, 'autoPlacement', {\n    enumerable: true,\n    get: function () {\n      return reactDom.autoPlacement;\n    }\n  });\n  Object.defineProperty(exports, 'autoUpdate', {\n    enumerable: true,\n    get: function () {\n      return reactDom.autoUpdate;\n    }\n  });\n  Object.defineProperty(exports, 'computePosition', {\n    enumerable: true,\n    get: function () {\n      return reactDom.computePosition;\n    }\n  });\n  Object.defineProperty(exports, 'detectOverflow', {\n    enumerable: true,\n    get: function () {\n      return reactDom.detectOverflow;\n    }\n  });\n  Object.defineProperty(exports, 'flip', {\n    enumerable: true,\n    get: function () {\n      return reactDom.flip;\n    }\n  });\n  Object.defineProperty(exports, 'getOverflowAncestors', {\n    enumerable: true,\n    get: function () {\n      return reactDom.getOverflowAncestors;\n    }\n  });\n  Object.defineProperty(exports, 'hide', {\n    enumerable: true,\n    get: function () {\n      return reactDom.hide;\n    }\n  });\n  Object.defineProperty(exports, 'inline', {\n    enumerable: true,\n    get: function () {\n      return reactDom.inline;\n    }\n  });\n  Object.defineProperty(exports, 'limitShift', {\n    enumerable: true,\n    get: function () {\n      return reactDom.limitShift;\n    }\n  });\n  Object.defineProperty(exports, 'offset', {\n    enumerable: true,\n    get: function () {\n      return reactDom.offset;\n    }\n  });\n  Object.defineProperty(exports, 'platform', {\n    enumerable: true,\n    get: function () {\n      return reactDom.platform;\n    }\n  });\n  Object.defineProperty(exports, 'shift', {\n    enumerable: true,\n    get: function () {\n      return reactDom.shift;\n    }\n  });\n  Object.defineProperty(exports, 'size', {\n    enumerable: true,\n    get: function () {\n      return reactDom.size;\n    }\n  });\n  exports.FloatingArrow = FloatingArrow;\n  exports.FloatingDelayGroup = FloatingDelayGroup;\n  exports.FloatingFocusManager = FloatingFocusManager;\n  exports.FloatingList = FloatingList;\n  exports.FloatingNode = FloatingNode;\n  exports.FloatingOverlay = FloatingOverlay;\n  exports.FloatingPortal = FloatingPortal;\n  exports.FloatingTree = FloatingTree;\n  exports.inner = inner;\n  exports.safePolygon = safePolygon;\n  exports.useClick = useClick;\n  exports.useClientPoint = useClientPoint;\n  exports.useDelayGroup = useDelayGroup;\n  exports.useDelayGroupContext = useDelayGroupContext;\n  exports.useDismiss = useDismiss;\n  exports.useFloating = useFloating;\n  exports.useFloatingNodeId = useFloatingNodeId;\n  exports.useFloatingParentNodeId = useFloatingParentNodeId;\n  exports.useFloatingPortalNode = useFloatingPortalNode;\n  exports.useFloatingTree = useFloatingTree;\n  exports.useFocus = useFocus;\n  exports.useHover = useHover;\n  exports.useId = useId;\n  exports.useInnerOffset = useInnerOffset;\n  exports.useInteractions = useInteractions;\n  exports.useListItem = useListItem;\n  exports.useListNavigation = useListNavigation;\n  exports.useMergeRefs = useMergeRefs;\n  exports.useRole = useRole;\n  exports.useTransitionStatus = useTransitionStatus;\n  exports.useTransitionStyles = useTransitionStyles;\n  exports.useTypeahead = useTypeahead;\n});","map":null,"metadata":{},"sourceType":"script"}