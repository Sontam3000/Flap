{"ast":null,"code":"'use client';\n\nimport { useState, useCallback } from 'react';\nimport { useDelayGroupContext, useFloating, offset, shift, flip, arrow, inline, useInteractions, useHover, useFocus, useRole, useDismiss, useDelayGroup } from '@floating-ui/react';\nimport { useId, useDidUpdate } from '@mantine/hooks';\nimport { useFloatingAutoUpdate } from '../Floating/use-floating-auto-update.mjs';\nimport '../Floating/FloatingArrow/FloatingArrow.mjs';\nimport { useTooltipGroupContext } from './TooltipGroup/TooltipGroup.context.mjs';\nfunction useTooltip(settings) {\n  var _settings$events, _settings$events2, _settings$events3;\n  const [uncontrolledOpened, setUncontrolledOpened] = useState(false);\n  const controlled = typeof settings.opened === \"boolean\";\n  const opened = controlled ? settings.opened : uncontrolledOpened;\n  const withinGroup = useTooltipGroupContext();\n  const uid = useId();\n  const {\n    delay: groupDelay,\n    currentId,\n    setCurrentId\n  } = useDelayGroupContext();\n  const onChange = useCallback(_opened => {\n    setUncontrolledOpened(_opened);\n    if (_opened) {\n      setCurrentId(uid);\n    }\n  }, [setCurrentId, uid]);\n  const {\n    x,\n    y,\n    context,\n    refs,\n    update,\n    placement,\n    middlewareData: {\n      arrow: {\n        x: arrowX,\n        y: arrowY\n      } = {}\n    }\n  } = useFloating({\n    placement: settings.position,\n    open: opened,\n    onOpenChange: onChange,\n    middleware: [offset(settings.offset), shift({\n      padding: 8\n    }), flip(), arrow({\n      element: settings.arrowRef,\n      padding: settings.arrowOffset\n    }), ...(settings.inline ? [inline()] : [])]\n  });\n  const {\n    getReferenceProps,\n    getFloatingProps\n  } = useInteractions([useHover(context, {\n    enabled: (_settings$events = settings.events) === null || _settings$events === void 0 ? void 0 : _settings$events.hover,\n    delay: withinGroup ? groupDelay : {\n      open: settings.openDelay,\n      close: settings.closeDelay\n    },\n    mouseOnly: !((_settings$events2 = settings.events) === null || _settings$events2 === void 0 ? void 0 : _settings$events2.touch)\n  }), useFocus(context, {\n    enabled: (_settings$events3 = settings.events) === null || _settings$events3 === void 0 ? void 0 : _settings$events3.focus,\n    keyboardOnly: true\n  }), useRole(context, {\n    role: \"tooltip\"\n  }),\n  // cannot be used with controlled tooltip, page jumps\n  useDismiss(context, {\n    enabled: typeof settings.opened === \"undefined\"\n  }), useDelayGroup(context, {\n    id: uid\n  })]);\n  useFloatingAutoUpdate({\n    opened,\n    position: settings.position,\n    positionDependencies: settings.positionDependencies,\n    floating: {\n      refs,\n      update\n    }\n  });\n  useDidUpdate(() => {\n    var _settings$onPositionC;\n    (_settings$onPositionC = settings.onPositionChange) === null || _settings$onPositionC === void 0 ? void 0 : _settings$onPositionC.call(settings, placement);\n  }, [placement]);\n  const isGroupPhase = opened && currentId && currentId !== uid;\n  return {\n    x,\n    y,\n    arrowX,\n    arrowY,\n    reference: refs.setReference,\n    floating: refs.setFloating,\n    getFloatingProps,\n    getReferenceProps,\n    isGroupPhase,\n    opened,\n    placement\n  };\n}\nexport { useTooltip };","map":null,"metadata":{},"sourceType":"module"}