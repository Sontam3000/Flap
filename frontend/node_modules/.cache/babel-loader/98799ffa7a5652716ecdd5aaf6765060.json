{"ast":null,"code":"'use client';\n\nimport React, { useState, useRef, useCallback } from 'react';\nimport { useUncontrolled, clamp, useMove, useMergedRef } from '@mantine/hooks';\nimport { rem } from '../../../core/utils/units-converters/rem.mjs';\nimport { getSize, getRadius } from '../../../core/utils/get-size/get-size.mjs';\nimport { createVarsResolver } from '../../../core/styles-api/create-vars-resolver/create-vars-resolver.mjs';\nimport 'clsx';\nimport { getThemeColor } from '../../../core/MantineProvider/color-functions/get-theme-color/get-theme-color.mjs';\nimport '../../../core/MantineProvider/Mantine.context.mjs';\nimport '../../../core/MantineProvider/default-theme.mjs';\nimport '../../../core/MantineProvider/MantineProvider.mjs';\nimport '../../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport { useProps } from '../../../core/MantineProvider/use-props/use-props.mjs';\nimport { useStyles } from '../../../core/styles-api/use-styles/use-styles.mjs';\nimport '../../../core/Box/Box.mjs';\nimport { factory } from '../../../core/factory/factory.mjs';\nimport { useDirection } from '../../../core/DirectionProvider/DirectionProvider.mjs';\nimport { SliderProvider } from '../Slider.context.mjs';\nimport { SliderRoot } from '../SliderRoot/SliderRoot.mjs';\nimport { Thumb } from '../Thumb/Thumb.mjs';\nimport { Track } from '../Track/Track.mjs';\nimport { getChangeValue } from '../utils/get-change-value/get-change-value.mjs';\nimport { getFloatingValue } from '../utils/get-floating-value/get-gloating-value.mjs';\nimport { getPosition } from '../utils/get-position/get-position.mjs';\nimport { getPrecision } from '../utils/get-precision/get-precision.mjs';\nimport classes from '../Slider.module.css.mjs';\nconst defaultProps = {\n  radius: \"xl\",\n  min: 0,\n  max: 100,\n  step: 1,\n  marks: [],\n  label: f => f,\n  labelTransitionProps: {\n    transition: \"fade\",\n    duration: 0\n  },\n  labelAlwaysOn: false,\n  thumbLabel: \"\",\n  showLabelOnHover: true,\n  disabled: false,\n  scale: v => v\n};\nconst varsResolver = createVarsResolver((theme, _ref) => {\n  let {\n    size,\n    color,\n    thumbSize,\n    radius\n  } = _ref;\n  return {\n    root: {\n      \"--slider-size\": getSize(size, \"slider-size\"),\n      \"--slider-color\": color ? getThemeColor(color, theme) : void 0,\n      \"--slider-radius\": radius === void 0 ? void 0 : getRadius(radius),\n      \"--slider-thumb-size\": thumbSize !== void 0 ? rem(thumbSize) : \"calc(var(--slider-size) * 2)\"\n    }\n  };\n});\nconst Slider = factory((_props, ref) => {\n  const props = useProps(\"Slider\", defaultProps, _props);\n  const {\n    classNames,\n    styles,\n    value,\n    onChange,\n    onChangeEnd,\n    size,\n    min,\n    max,\n    step,\n    precision: _precision,\n    defaultValue,\n    name,\n    marks,\n    label,\n    labelTransitionProps,\n    labelAlwaysOn,\n    thumbLabel,\n    showLabelOnHover,\n    thumbChildren,\n    disabled,\n    unstyled,\n    scale,\n    inverted,\n    className,\n    style,\n    vars,\n    hiddenInputProps,\n    ...others\n  } = props;\n  const getStyles = useStyles({\n    name: \"Slider\",\n    props,\n    classes,\n    classNames,\n    className,\n    styles,\n    style,\n    vars,\n    varsResolver,\n    unstyled\n  });\n  const {\n    dir\n  } = useDirection();\n  const [hovered, setHovered] = useState(false);\n  const [_value, setValue] = useUncontrolled({\n    value: typeof value === \"number\" ? clamp(value, min, max) : value,\n    defaultValue: typeof defaultValue === \"number\" ? clamp(defaultValue, min, max) : defaultValue,\n    finalValue: clamp(0, min, max),\n    onChange\n  });\n  const valueRef = useRef(_value);\n  const root = useRef();\n  const thumb = useRef();\n  const position = getPosition({\n    value: _value,\n    min,\n    max\n  });\n  const scaledValue = scale(_value);\n  const _label = typeof label === \"function\" ? label(scaledValue) : label;\n  const precision = _precision !== null && _precision !== void 0 ? _precision : getPrecision(step);\n  const handleChange = useCallback(_ref2 => {\n    let {\n      x\n    } = _ref2;\n    if (!disabled) {\n      const nextValue = getChangeValue({\n        value: x,\n        min,\n        max,\n        step,\n        precision\n      });\n      setValue(nextValue);\n      valueRef.current = nextValue;\n    }\n  }, [disabled, min, max, step, precision, setValue]);\n  const {\n    ref: container,\n    active\n  } = useMove(handleChange, {\n    onScrubEnd: () => onChangeEnd === null || onChangeEnd === void 0 ? void 0 : onChangeEnd(valueRef.current)\n  }, dir);\n  const handleTrackKeydownCapture = event => {\n    if (!disabled) {\n      switch (event.key) {\n        case \"ArrowUp\":\n          {\n            var _thumb$current;\n            event.preventDefault();\n            (_thumb$current = thumb.current) === null || _thumb$current === void 0 ? void 0 : _thumb$current.focus();\n            const nextValue = getFloatingValue(Math.min(Math.max(_value + step, min), max), precision);\n            onChangeEnd === null || onChangeEnd === void 0 ? void 0 : onChangeEnd(nextValue);\n            setValue(nextValue);\n            break;\n          }\n        case \"ArrowRight\":\n          {\n            var _thumb$current2;\n            event.preventDefault();\n            (_thumb$current2 = thumb.current) === null || _thumb$current2 === void 0 ? void 0 : _thumb$current2.focus();\n            const nextValue = getFloatingValue(Math.min(Math.max(dir === \"rtl\" ? _value - step : _value + step, min), max), precision);\n            onChangeEnd === null || onChangeEnd === void 0 ? void 0 : onChangeEnd(nextValue);\n            setValue(nextValue);\n            break;\n          }\n        case \"ArrowDown\":\n          {\n            var _thumb$current3;\n            event.preventDefault();\n            (_thumb$current3 = thumb.current) === null || _thumb$current3 === void 0 ? void 0 : _thumb$current3.focus();\n            const nextValue = getFloatingValue(Math.min(Math.max(_value - step, min), max), precision);\n            onChangeEnd === null || onChangeEnd === void 0 ? void 0 : onChangeEnd(nextValue);\n            setValue(nextValue);\n            break;\n          }\n        case \"ArrowLeft\":\n          {\n            var _thumb$current4;\n            event.preventDefault();\n            (_thumb$current4 = thumb.current) === null || _thumb$current4 === void 0 ? void 0 : _thumb$current4.focus();\n            const nextValue = getFloatingValue(Math.min(Math.max(dir === \"rtl\" ? _value + step : _value - step, min), max), precision);\n            onChangeEnd === null || onChangeEnd === void 0 ? void 0 : onChangeEnd(nextValue);\n            setValue(nextValue);\n            break;\n          }\n        case \"Home\":\n          {\n            var _thumb$current5;\n            event.preventDefault();\n            (_thumb$current5 = thumb.current) === null || _thumb$current5 === void 0 ? void 0 : _thumb$current5.focus();\n            onChangeEnd === null || onChangeEnd === void 0 ? void 0 : onChangeEnd(min);\n            setValue(min);\n            break;\n          }\n        case \"End\":\n          {\n            var _thumb$current6;\n            event.preventDefault();\n            (_thumb$current6 = thumb.current) === null || _thumb$current6 === void 0 ? void 0 : _thumb$current6.focus();\n            onChangeEnd === null || onChangeEnd === void 0 ? void 0 : onChangeEnd(max);\n            setValue(max);\n            break;\n          }\n      }\n    }\n  };\n  return /* @__PURE__ */React.createElement(SliderProvider, {\n    value: {\n      getStyles\n    }\n  }, /* @__PURE__ */React.createElement(SliderRoot, {\n    ...others,\n    ref: useMergedRef(ref, root),\n    onKeyDownCapture: handleTrackKeydownCapture,\n    onMouseDownCapture: () => {\n      var _root$current;\n      return (_root$current = root.current) === null || _root$current === void 0 ? void 0 : _root$current.focus();\n    },\n    size,\n    disabled\n  }, /* @__PURE__ */React.createElement(Track, {\n    inverted,\n    offset: 0,\n    filled: position,\n    marks,\n    min,\n    max,\n    value: scaledValue,\n    disabled,\n    containerProps: {\n      ref: container,\n      onMouseEnter: showLabelOnHover ? () => setHovered(true) : void 0,\n      onMouseLeave: showLabelOnHover ? () => setHovered(false) : void 0\n    }\n  }, /* @__PURE__ */React.createElement(Thumb, {\n    max,\n    min,\n    value: scaledValue,\n    position,\n    dragging: active,\n    label: _label,\n    ref: thumb,\n    labelTransitionProps,\n    labelAlwaysOn,\n    thumbLabel,\n    showLabelOnHover,\n    isHovered: hovered,\n    disabled\n  }, thumbChildren)), /* @__PURE__ */React.createElement(\"input\", {\n    type: \"hidden\",\n    name,\n    value: scaledValue,\n    ...hiddenInputProps\n  })));\n});\nSlider.classes = classes;\nSlider.displayName = \"@mantine/core/Slider\";\nexport { Slider };","map":null,"metadata":{},"sourceType":"module"}