{"ast":null,"code":"'use client';\n\nimport React, { useRef } from 'react';\nimport cx from 'clsx';\nimport { NumericFormat } from 'react-number-format';\nimport { useUncontrolled, clamp, assignRef, useMergedRef } from '@mantine/hooks';\nimport { getSize } from '../../core/utils/get-size/get-size.mjs';\nimport { createVarsResolver } from '../../core/styles-api/create-vars-resolver/create-vars-resolver.mjs';\nimport { useResolvedStylesApi } from '../../core/styles-api/use-resolved-styles-api/use-resolved-styles-api.mjs';\nimport { useStyles } from '../../core/styles-api/use-styles/use-styles.mjs';\nimport '../../core/MantineProvider/Mantine.context.mjs';\nimport '../../core/MantineProvider/default-theme.mjs';\nimport '../../core/MantineProvider/MantineProvider.mjs';\nimport '../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport { useProps } from '../../core/MantineProvider/use-props/use-props.mjs';\nimport '../../core/Box/Box.mjs';\nimport { factory } from '../../core/factory/factory.mjs';\nimport '../../core/DirectionProvider/DirectionProvider.mjs';\nimport { InputBase } from '../InputBase/InputBase.mjs';\nimport { UnstyledButton } from '../UnstyledButton/UnstyledButton.mjs';\nimport { NumberInputChevron } from './NumberInputChevron.mjs';\nimport classes from './NumberInput.module.css.mjs';\nconst partialNegativeNumberPattern = /^-0(\\.0*)?$/;\nconst leadingZerosPattern = /^-?0\\d+$/;\nfunction isValidNumber(value) {\n  return (typeof value === \"number\" ? value < Number.MAX_SAFE_INTEGER : !Number.isNaN(Number(value))) && !Number.isNaN(value);\n}\nfunction getDecrementedValue(_ref) {\n  let {\n    value,\n    min,\n    step = 1,\n    allowNegative\n  } = _ref;\n  const nextValue = value - step;\n  if (min !== void 0 && nextValue < min) {\n    return min;\n  }\n  if (!allowNegative && nextValue < 0 && min === void 0) {\n    return value;\n  }\n  if (min !== void 0 && min >= 0 && nextValue <= min) {\n    return nextValue;\n  }\n  return nextValue;\n}\nfunction isInRange(value, min, max) {\n  if (value === void 0) {\n    return true;\n  }\n  const minValid = min === void 0 || value >= min;\n  const maxValid = max === void 0 || value <= max;\n  return minValid && maxValid;\n}\nconst defaultProps = {\n  step: 1,\n  clampBehavior: \"blur\",\n  allowDecimal: true,\n  allowNegative: true,\n  startValue: 0\n};\nconst varsResolver = createVarsResolver((_, _ref2) => {\n  let {\n    size\n  } = _ref2;\n  return {\n    controls: {\n      \"--ni-chevron-size\": getSize(size, \"ni-chevron-size\")\n    }\n  };\n});\nconst NumberInput = factory((_props, ref) => {\n  const props = useProps(\"NumberInput\", defaultProps, _props);\n  const {\n    className,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    onChange,\n    onValueChange,\n    value,\n    defaultValue,\n    max,\n    min,\n    step,\n    hideControls,\n    rightSection,\n    isAllowed,\n    clampBehavior,\n    onBlur,\n    allowDecimal,\n    decimalScale,\n    onKeyDown,\n    handlersRef,\n    startValue,\n    disabled,\n    rightSectionPointerEvents,\n    allowNegative,\n    readOnly,\n    size,\n    rightSectionWidth,\n    stepHoldInterval,\n    stepHoldDelay,\n    allowLeadingZeros,\n    ...others\n  } = props;\n  const getStyles = useStyles({\n    name: \"NumberInput\",\n    classes,\n    props,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    varsResolver\n  });\n  const {\n    resolvedClassNames,\n    resolvedStyles\n  } = useResolvedStylesApi({\n    classNames,\n    styles,\n    props\n  });\n  const [_value, setValue] = useUncontrolled({\n    value,\n    defaultValue,\n    onChange\n  });\n  const shouldUseStepInterval = stepHoldDelay !== void 0 && stepHoldInterval !== void 0;\n  const inputRef = useRef(null);\n  const onStepTimeoutRef = useRef(null);\n  const stepCountRef = useRef(0);\n  const handleValueChange = (payload, event) => {\n    if (event.source === \"event\") {\n      setValue(isValidNumber(payload.floatValue) && !partialNegativeNumberPattern.test(payload.value) && !(allowLeadingZeros ? leadingZerosPattern.test(payload.value) : false) ? payload.floatValue : payload.value);\n    }\n    onValueChange === null || onValueChange === void 0 ? void 0 : onValueChange(payload, event);\n  };\n  const incrementRef = useRef();\n  incrementRef.current = () => {\n    if (typeof _value !== \"number\" || Number.isNaN(_value)) {\n      setValue(clamp(startValue, min, max));\n    } else if (max !== void 0) {\n      setValue(_value + step <= max ? _value + step : max);\n    } else {\n      setValue(_value + step);\n    }\n  };\n  const decrementRef = useRef();\n  decrementRef.current = () => {\n    if (typeof _value !== \"number\" || Number.isNaN(_value)) {\n      setValue(clamp(startValue, min, max));\n    } else {\n      setValue(getDecrementedValue({\n        value: _value,\n        min,\n        step,\n        allowNegative\n      }));\n    }\n  };\n  const handleKeyDown = event => {\n    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);\n    if (readOnly) {\n      return;\n    }\n    if (event.key === \"ArrowUp\") {\n      event.preventDefault();\n      incrementRef.current();\n    }\n    if (event.key === \"ArrowDown\") {\n      event.preventDefault();\n      decrementRef.current();\n    }\n  };\n  assignRef(handlersRef, {\n    increment: incrementRef.current,\n    decrement: decrementRef.current\n  });\n  const onStepHandleChange = isIncrement => {\n    if (isIncrement) {\n      incrementRef.current();\n    } else {\n      decrementRef.current();\n    }\n    stepCountRef.current += 1;\n  };\n  const onStepLoop = isIncrement => {\n    onStepHandleChange(isIncrement);\n    if (shouldUseStepInterval) {\n      const interval = typeof stepHoldInterval === \"number\" ? stepHoldInterval : stepHoldInterval(stepCountRef.current);\n      onStepTimeoutRef.current = window.setTimeout(() => onStepLoop(isIncrement), interval);\n    }\n  };\n  const onStep = (event, isIncrement) => {\n    var _inputRef$current;\n    event.preventDefault();\n    (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();\n    onStepHandleChange(isIncrement);\n    if (shouldUseStepInterval) {\n      onStepTimeoutRef.current = window.setTimeout(() => onStepLoop(isIncrement), stepHoldDelay);\n    }\n  };\n  const onStepDone = () => {\n    if (onStepTimeoutRef.current) {\n      window.clearTimeout(onStepTimeoutRef.current);\n    }\n    onStepTimeoutRef.current = null;\n    stepCountRef.current = 0;\n  };\n  const controls = /* @__PURE__ */React.createElement(\"div\", {\n    ...getStyles(\"controls\")\n  }, /* @__PURE__ */React.createElement(UnstyledButton, {\n    ...getStyles(\"control\"),\n    tabIndex: -1,\n    \"aria-hidden\": true,\n    disabled: disabled || typeof _value === \"number\" && max !== void 0 && _value >= max,\n    mod: {\n      direction: \"up\"\n    },\n    onMouseDown: event => event.preventDefault(),\n    onPointerDown: event => {\n      onStep(event, true);\n    },\n    onPointerUp: onStepDone,\n    onPointerLeave: onStepDone\n  }, /* @__PURE__ */React.createElement(NumberInputChevron, {\n    direction: \"up\"\n  })), /* @__PURE__ */React.createElement(UnstyledButton, {\n    ...getStyles(\"control\"),\n    tabIndex: -1,\n    \"aria-hidden\": true,\n    disabled: disabled || typeof _value === \"number\" && min !== void 0 && _value <= min,\n    mod: {\n      direction: \"down\"\n    },\n    onMouseDown: event => event.preventDefault(),\n    onPointerDown: event => {\n      onStep(event, false);\n    },\n    onPointerUp: onStepDone,\n    onPointerLeave: onStepDone\n  }, /* @__PURE__ */React.createElement(NumberInputChevron, {\n    direction: \"down\"\n  })));\n  return /* @__PURE__ */React.createElement(InputBase, {\n    component: NumericFormat,\n    allowNegative,\n    className: cx(classes.root, className),\n    size,\n    ...others,\n    readOnly,\n    disabled,\n    value: _value,\n    getInputRef: useMergedRef(ref, inputRef),\n    onValueChange: handleValueChange,\n    rightSection: hideControls || readOnly ? rightSection : rightSection || controls,\n    classNames: resolvedClassNames,\n    styles: resolvedStyles,\n    unstyled,\n    __staticSelector: \"NumberInput\",\n    decimalScale: allowDecimal ? decimalScale : 0,\n    onKeyDown: handleKeyDown,\n    rightSectionPointerEvents: rightSectionPointerEvents !== null && rightSectionPointerEvents !== void 0 ? rightSectionPointerEvents : disabled ? \"none\" : void 0,\n    rightSectionWidth: rightSectionWidth !== null && rightSectionWidth !== void 0 ? rightSectionWidth : \"var(--ni-right-section-width-\".concat(size || \"sm\", \")\"),\n    allowLeadingZeros,\n    onBlur: event => {\n      onBlur === null || onBlur === void 0 ? void 0 : onBlur(event);\n      if (clampBehavior === \"blur\" && typeof _value === \"number\") {\n        const clampedValue = clamp(_value, min, max);\n        if (clampedValue !== _value) {\n          setValue(clamp(_value, min, max));\n        }\n      }\n    },\n    isAllowed: val => {\n      if (clampBehavior === \"strict\") {\n        if (isAllowed) {\n          return isAllowed(val) && isInRange(val.floatValue, min, max);\n        }\n        return isInRange(val.floatValue, min, max);\n      }\n      return isAllowed ? isAllowed(val) : true;\n    }\n  });\n});\nNumberInput.classes = {\n  ...InputBase.classes,\n  ...classes\n};\nNumberInput.displayName = \"@mantine/core/NumberInput\";\nexport { NumberInput };","map":null,"metadata":{},"sourceType":"module"}